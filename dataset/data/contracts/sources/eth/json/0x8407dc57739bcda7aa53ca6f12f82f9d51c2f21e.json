{"SourceCode": "// File: @axie/contract-library/contracts/cryptography/ECVerify.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\nlibrary ECVerify {\r\n\r\n  enum SignatureMode {\r\n    EIP712,\r\n    GETH,\r\n    TREZOR\r\n  }\r\n\r\n  function recover(bytes32 _hash, bytes memory _signature) internal pure returns (address _signer) {\r\n    return recover(_hash, _signature, 0);\r\n  }\r\n\r\n  // solium-disable-next-line security/no-assign-params\r\n  function recover(bytes32 _hash, bytes memory _signature, uint256 _index) internal pure returns (address _signer) {\r\n    require(_signature.length >= _index + 66);\r\n\r\n    SignatureMode _mode = SignatureMode(uint8(_signature[_index]));\r\n    bytes32 _r;\r\n    bytes32 _s;\r\n    uint8 _v;\r\n\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly {\r\n      _r := mload(add(_signature, add(_index, 33)))\r\n      _s := mload(add(_signature, add(_index, 65)))\r\n      _v := and(255, mload(add(_signature, add(_index, 66))))\r\n    }\r\n\r\n    if (_v < 27) {\r\n      _v += 27;\r\n    }\r\n\r\n    require(_v == 27 || _v == 28);\r\n\r\n    if (_mode == SignatureMode.GETH) {\r\n      _hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _hash));\r\n    } else if (_mode == SignatureMode.TREZOR) {\r\n      _hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\\x20\", _hash));\r\n    }\r\n\r\n    return ecrecover(_hash, _v, _r, _s);\r\n  }\r\n\r\n  function ecverify(bytes32 _hash, bytes memory _signature, address _signer) internal pure returns (bool _valid) {\r\n    return _signer == recover(_hash, _signature);\r\n  }\r\n}\r\n\r\n// File: @axie/contract-library/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\nlibrary SafeMath {\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    require(c >= a);\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    require(c / a == b);\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Since Solidity automatically asserts when dividing by 0,\r\n    // but we only need it to revert.\r\n    require(b > 0);\r\n    return a / b;\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Same reason as `div`.\r\n    require(b > 0);\r\n    return a % b;\r\n  }\r\n\r\n  function ceilingDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    return add(div(a, b), mod(a, b) > 0 ? 1 : 0);\r\n  }\r\n\r\n  function subU64(uint64 a, uint64 b) internal pure returns (uint64 c) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function addU8(uint8 a, uint8 b) internal pure returns (uint8 c) {\r\n    c = a + b;\r\n    require(c >= a);\r\n  }\r\n}\r\n\r\n// File: @axie/contract-library/contracts/token/erc20/IERC20.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ninterface IERC20 {\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n  function totalSupply() external view returns (uint256 _supply);\r\n  function balanceOf(address _owner) external view returns (uint256 _balance);\r\n\r\n  function approve(address _spender, uint256 _value) external returns (bool _success);\r\n  function allowance(address _owner, address _spender) external view returns (uint256 _value);\r\n\r\n  function transfer(address _to, uint256 _value) external returns (bool _success);\r\n  function transferFrom(address _from, address _to, uint256 _value) external returns (bool _success);\r\n}\r\n\r\n// File: @axie/contract-library/contracts/token/erc20/IERC20Mintable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ninterface IERC20Mintable {\r\n  function mint(address _to, uint256 _value) external returns (bool _success);\r\n}\r\n\r\n// File: @axie/contract-library/contracts/token/erc721/IERC721.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ninterface IERC721 {\r\n  event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n  event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n  function balanceOf(address _owner) external view returns (uint256 _balance);\r\n  function ownerOf(uint256 _tokenId) external view returns (address _owner);\r\n\r\n  function approve(address _to, uint256 _tokenId) external;\r\n  function getApproved(uint256 _tokenId) external view returns (address _operator);\r\n\r\n  function setApprovalForAll(address _operator, bool _approved) external;\r\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool _approved);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;\r\n}\r\n\r\n// File: @axie/contract-library/contracts/token/erc721/IERC721Mintable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ninterface IERC721Mintable {\r\n  function mint(address _to, uint256 _tokenId) external returns (bool);\r\n  function mintNew(address _to) external returns (uint256 _tokenId);\r\n}\r\n\r\n// File: @axie/contract-library/contracts/util/AddressUtils.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\nlibrary AddressUtils {\r\n  function toPayable(address _address) internal pure returns (address payable _payable) {\r\n    return address(uint160(_address));\r\n  }\r\n\r\n  function isContract(address _address) internal view returns (bool _correct) {\r\n    uint256 _size;\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly { _size := extcodesize(_address) }\r\n    return _size > 0;\r\n  }\r\n}\r\n\r\n// File: @axie/contract-library/contracts/token/erc20/ERC20.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\ncontract ERC20 is IERC20 {\r\n  using SafeMath for uint256;\r\n\r\n  uint256 public totalSupply;\r\n  mapping (address => uint256) public balanceOf;\r\n  mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool _success) {\r\n    allowance[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function transfer(address _to, uint256 _value) public returns (bool _success) {\r\n    require(_to != address(0));\r\n    balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\r\n    balanceOf[_to] = balanceOf[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {\r\n    require(_to != address(0));\r\n    balanceOf[_from] = balanceOf[_from].sub(_value);\r\n    balanceOf[_to] = balanceOf[_to].add(_value);\r\n    allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n}\r\n\r\n// File: @axie/contract-library/contracts/token/erc20/IERC20Detailed.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ninterface IERC20Detailed {\r\n  function name() external view returns (string memory _name);\r\n  function symbol() external view returns (string memory _symbol);\r\n  function decimals() external view returns (uint8 _decimals);\r\n}\r\n\r\n// File: @axie/contract-library/contracts/token/erc20/ERC20Detailed.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\ncontract ERC20Detailed is ERC20, IERC20Detailed {\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals;\r\n\r\n  constructor(string memory _name, string memory _symbol, uint8 _decimals) public {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n  }\r\n}\r\n\r\n// File: @axie/contract-library/contracts/access/HasAdmin.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract HasAdmin {\r\n  event AdminChanged(address indexed _oldAdmin, address indexed _newAdmin);\r\n  event AdminRemoved(address indexed _oldAdmin);\r\n\r\n  address public admin;\r\n\r\n  modifier onlyAdmin {\r\n    require(msg.sender == admin);\r\n    _;\r\n  }\r\n\r\n  constructor() internal {\r\n    admin = msg.sender;\r\n    emit AdminChanged(address(0), admin);\r\n  }\r\n\r\n  function changeAdmin(address _newAdmin) external onlyAdmin {\r\n    require(_newAdmin != address(0));\r\n    emit AdminChanged(admin, _newAdmin);\r\n    admin = _newAdmin;\r\n  }\r\n\r\n  function removeAdmin() external onlyAdmin {\r\n    emit AdminRemoved(admin);\r\n    admin = address(0);\r\n  }\r\n}\r\n\r\n// File: @axie/contract-library/contracts/access/HasMinters.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\ncontract HasMinters is HasAdmin {\r\n  event MinterAdded(address indexed _minter);\r\n  event MinterRemoved(address indexed _minter);\r\n\r\n  address[] public minters;\r\n  mapping (address => bool) public minter;\r\n\r\n  modifier onlyMinter {\r\n    require(minter[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  function addMinters(address[] memory _addedMinters) public onlyAdmin {\r\n    address _minter;\r\n\r\n    for (uint256 i = 0; i < _addedMinters.length; i++) {\r\n      _minter = _addedMinters[i];\r\n\r\n      if (!minter[_minter]) {\r\n        minters.push(_minter);\r\n        minter[_minter] = true;\r\n        emit MinterAdded(_minter);\r\n      }\r\n    }\r\n  }\r\n\r\n  function removeMinters(address[] memory _removedMinters) public onlyAdmin {\r\n    address _minter;\r\n\r\n    for (uint256 i = 0; i < _removedMinters.length; i++) {\r\n      _minter = _removedMinters[i];\r\n\r\n      if (minter[_minter]) {\r\n        minter[_minter] = false;\r\n        emit MinterRemoved(_minter);\r\n      }\r\n    }\r\n\r\n    uint256 i = 0;\r\n\r\n    while (i < minters.length) {\r\n      _minter = minters[i];\r\n\r\n      if (!minter[_minter]) {\r\n        minters[i] = minters[minters.length - 1];\r\n        delete minters[minters.length - 1];\r\n        minters.length--;\r\n      } else {\r\n        i++;\r\n      }\r\n    }\r\n  }\r\n\r\n  function isMinter(address _addr) public view returns (bool) {\r\n    return minter[_addr];\r\n  }\r\n}\r\n\r\n// File: @axie/contract-library/contracts/token/erc20/ERC20Mintable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\ncontract ERC20Mintable is HasMinters, ERC20 {\r\n  function mint(address _to, uint256 _value) public onlyMinter returns (bool _success) {\r\n    return _mint(_to, _value);\r\n  }\r\n\r\n  function _mint(address _to, uint256 _value) internal returns (bool success) {\r\n    totalSupply = totalSupply.add(_value);\r\n    balanceOf[_to] = balanceOf[_to].add(_value);\r\n    emit Transfer(address(0), _to, _value);\r\n    return true;\r\n  }\r\n}\r\n\r\n// File: contracts/chain/mainchain/WETH.sol\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\n\r\n\r\ncontract WETH is ERC20Detailed {\r\n\r\n  event Deposit(\r\n    address _sender,\r\n    uint256 _value\r\n  );\r\n\r\n  event Withdrawal(\r\n    address _sender,\r\n    uint256 _value\r\n  );\r\n\r\n  constructor () ERC20Detailed(\"Wrapped Ether\", \"WETH\", 18)\r\n    public\r\n  {}\r\n\r\n  function deposit()\r\n    external\r\n    payable\r\n  {\r\n    balanceOf[msg.sender] += msg.value;\r\n\r\n    emit Deposit(msg.sender, msg.value);\r\n  }\r\n\r\n  function withdraw(uint256 _wad)\r\n    external\r\n  {\r\n    require(balanceOf[msg.sender] >= _wad);\r\n    balanceOf[msg.sender] -= _wad;\r\n    msg.sender.transfer(_wad);\r\n\r\n    emit Withdrawal(msg.sender, _wad);\r\n  }\r\n}\r\n\r\n// File: @axie/contract-library/contracts/proxy/ProxyStorage.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title ProxyStorage\r\n * @dev Store the address of logic contact that the proxy should forward to.\r\n */\r\ncontract ProxyStorage is HasAdmin {\r\n  address internal _proxyTo;\r\n}\r\n\r\n// File: @axie/contract-library/contracts/lifecycle/Pausable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\ncontract Pausable is HasAdmin {\r\n  event Paused();\r\n  event Unpaused();\r\n\r\n  bool public paused;\r\n\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  function pause() public onlyAdmin whenNotPaused {\r\n    paused = true;\r\n    emit Paused();\r\n  }\r\n\r\n  function unpause() public onlyAdmin whenPaused {\r\n    paused = false;\r\n    emit Unpaused();\r\n  }\r\n}\r\n\r\n// File: contracts/chain/common/IValidator.sol\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\ncontract IValidator {\r\n  event ValidatorAdded(uint256 indexed _id, address indexed _validator);\r\n  event ValidatorRemoved(uint256 indexed _id, address indexed _validator);\r\n  event ThresholdUpdated(\r\n    uint256 indexed _id,\r\n    uint256 indexed _numerator,\r\n    uint256 indexed _denominator,\r\n    uint256 _previousNumerator,\r\n    uint256 _previousDenominator\r\n  );\r\n\r\n  function isValidator(address _addr) public view returns (bool);\r\n  function getValidators() public view returns (address[] memory _validators);\r\n\r\n  function checkThreshold(uint256 _voteCount) public view returns (bool);\r\n}\r\n\r\n// File: contracts/chain/common/Validator.sol\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\n\r\n\r\ncontract Validator is IValidator {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => bool) validatorMap;\r\n  address[] public validators;\r\n  uint256 public validatorCount;\r\n\r\n  uint256 public num;\r\n  uint256 public denom;\r\n\r\n  constructor(address[] memory _validators, uint256 _num, uint256 _denom)\r\n    public\r\n  {\r\n    validators = _validators;\r\n    validatorCount = _validators.length;\r\n\r\n    for (uint256 _i = 0; _i < validatorCount; _i++) {\r\n      address _validator = _validators[_i];\r\n      validatorMap[_validator] = true;\r\n    }\r\n\r\n    num = _num;\r\n    denom = _denom;\r\n  }\r\n\r\n  function isValidator(address _addr)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return validatorMap[_addr];\r\n  }\r\n\r\n  function getValidators()\r\n    public\r\n    view\r\n    returns (address[] memory _validators)\r\n  {\r\n    _validators = validators;\r\n  }\r\n\r\n  function checkThreshold(uint256 _voteCount)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return _voteCount.mul(denom) >= num.mul(validatorCount);\r\n  }\r\n\r\n  function _addValidator(uint256 _id, address _validator)\r\n    internal\r\n  {\r\n    require(!validatorMap[_validator]);\r\n\r\n    validators.push(_validator);\r\n    validatorMap[_validator] = true;\r\n    validatorCount++;\r\n\r\n    emit ValidatorAdded(_id, _validator);\r\n  }\r\n\r\n  function _removeValidator(uint256 _id, address _validator)\r\n    internal\r\n  {\r\n    require(isValidator(_validator));\r\n\r\n    uint256 _index;\r\n    for (uint256 _i = 0; _i < validatorCount; _i++) {\r\n      if (validators[_i] == _validator) {\r\n        _index = _i;\r\n        break;\r\n      }\r\n    }\r\n\r\n    validatorMap[_validator] = false;\r\n    validators[_index] = validators[validatorCount - 1];\r\n    validators.pop();\r\n\r\n    validatorCount--;\r\n\r\n    emit ValidatorRemoved(_id, _validator);\r\n  }\r\n\r\n  function _updateQuorum(uint256 _id, uint256 _numerator, uint256 _denominator)\r\n    internal\r\n  {\r\n    require(_numerator <= _denominator);\r\n    uint256 _previousNumerator = num;\r\n    uint256 _previousDenominator = denom;\r\n\r\n    num = _numerator;\r\n    denom = _denominator;\r\n\r\n    emit ThresholdUpdated(\r\n      _id,\r\n      _numerator,\r\n      _denominator,\r\n      _previousNumerator,\r\n      _previousDenominator\r\n    );\r\n  }\r\n}\r\n\r\n// File: contracts/chain/mainchain/MainchainValidator.sol\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Validator\r\n * @dev Simple validator contract\r\n */\r\ncontract MainchainValidator is Validator, HasAdmin {\r\n  uint256 nonce;\r\n\r\n  constructor(\r\n    address[] memory _validators,\r\n    uint256 _num,\r\n    uint256 _denom\r\n  ) Validator(_validators, _num, _denom) public {\r\n  }\r\n\r\n  function addValidators(address[] calldata _validators) external onlyAdmin {\r\n    for (uint256 _i; _i < _validators.length; ++_i) {\r\n      _addValidator(nonce++, _validators[_i]);\r\n    }\r\n  }\r\n\r\n  function removeValidator(address _validator) external onlyAdmin {\r\n    _removeValidator(nonce++, _validator);\r\n  }\r\n\r\n  function updateQuorum(uint256 _numerator, uint256 _denominator) external onlyAdmin {\r\n    _updateQuorum(nonce++, _numerator, _denominator);\r\n  }\r\n}\r\n\r\n// File: contracts/chain/common/Registry.sol\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\n\r\ncontract Registry is HasAdmin {\r\n\r\n  event ContractAddressUpdated(\r\n    string indexed _name,\r\n    bytes32 indexed _code,\r\n    address indexed _newAddress\r\n  );\r\n\r\n  event TokenMapped(\r\n    address indexed _mainchainToken,\r\n    address indexed _sidechainToken,\r\n    uint32 _standard\r\n  );\r\n\r\n  string public constant GATEWAY = \"GATEWAY\";\r\n  string public constant WETH_TOKEN = \"WETH_TOKEN\";\r\n  string public constant VALIDATOR = \"VALIDATOR\";\r\n  string public constant ACKNOWLEDGEMENT = \"ACKNOWLEDGEMENT\";\r\n\r\n  struct TokenMapping {\r\n    address mainchainToken;\r\n    address sidechainToken;\r\n    uint32 standard; // 20, 721 or any other standards\r\n  }\r\n\r\n  mapping(bytes32 => address) public contractAddresses;\r\n  mapping(address => TokenMapping) public mainchainMap;\r\n  mapping(address => TokenMapping) public sidechainMap;\r\n\r\n  function getContract(string calldata _name)\r\n    external\r\n    view\r\n    returns (address _address)\r\n  {\r\n    bytes32 _code = getCode(_name);\r\n    _address = contractAddresses[_code];\r\n    require(_address != address(0));\r\n  }\r\n\r\n  function isTokenMapped(address _token, uint32 _standard, bool _isMainchain)\r\n    external\r\n    view\r\n    returns (bool)\r\n  {\r\n    TokenMapping memory _mapping = _getTokenMapping(_token, _isMainchain);\r\n\r\n    return _mapping.mainchainToken != address(0) &&\r\n      _mapping.sidechainToken != address(0) &&\r\n      _mapping.standard == _standard;\r\n  }\r\n\r\n  function updateContract(string calldata _name, address _newAddress)\r\n    external\r\n    onlyAdmin\r\n  {\r\n    bytes32 _code = getCode(_name);\r\n    contractAddresses[_code] = _newAddress;\r\n\r\n    emit ContractAddressUpdated(_name, _code, _newAddress);\r\n  }\r\n\r\n  function mapToken(address _mainchainToken, address _sidechainToken, uint32 _standard)\r\n    external\r\n    onlyAdmin\r\n  {\r\n    TokenMapping memory _map = TokenMapping(\r\n      _mainchainToken,\r\n      _sidechainToken,\r\n      _standard\r\n    );\r\n\r\n    mainchainMap[_mainchainToken] = _map;\r\n    sidechainMap[_sidechainToken] = _map;\r\n\r\n    emit TokenMapped(\r\n      _mainchainToken,\r\n      _sidechainToken,\r\n      _standard\r\n    );\r\n  }\r\n\r\n  function clearMapToken(address _mainchainToken, address _sidechainToken)\r\n    external\r\n    onlyAdmin\r\n  {\r\n    TokenMapping storage _mainchainMap = mainchainMap[_mainchainToken];\r\n    _clearMapEntry(_mainchainMap);\r\n\r\n    TokenMapping storage _sidechainMap = sidechainMap[_sidechainToken];\r\n    _clearMapEntry(_sidechainMap);\r\n  }\r\n\r\n  function getMappedToken(\r\n    address _token,\r\n    bool _isMainchain\r\n  )\r\n    external\r\n    view\r\n  returns (\r\n    address _mainchainToken,\r\n    address _sidechainToken,\r\n    uint32 _standard\r\n  )\r\n  {\r\n    TokenMapping memory _mapping = _getTokenMapping(_token, _isMainchain);\r\n    _mainchainToken = _mapping.mainchainToken;\r\n    _sidechainToken = _mapping.sidechainToken;\r\n    _standard = _mapping.standard;\r\n  }\r\n\r\n  function getCode(string memory _name)\r\n    public\r\n    pure\r\n    returns (bytes32)\r\n  {\r\n    return keccak256(abi.encodePacked(_name));\r\n  }\r\n\r\n  function _getTokenMapping(\r\n    address _token,\r\n    bool isMainchain\r\n  )\r\n    internal\r\n    view\r\n    returns (TokenMapping memory _mapping)\r\n  {\r\n    if (isMainchain) {\r\n      _mapping = mainchainMap[_token];\r\n    } else {\r\n      _mapping = sidechainMap[_token];\r\n    }\r\n  }\r\n\r\n  function _clearMapEntry(TokenMapping storage _entry)\r\n    internal\r\n  {\r\n    _entry.mainchainToken = address(0);\r\n    _entry.sidechainToken = address(0);\r\n    _entry.standard = 0;\r\n  }\r\n}\r\n\r\n// File: contracts/chain/mainchain/MainchainGatewayStorage.sol\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title GatewayStorage\r\n * @dev Storage of deposit and withdraw information.\r\n */\r\ncontract MainchainGatewayStorage is ProxyStorage, Pausable {\r\n\r\n  event TokenDeposited(\r\n    uint256 indexed _depositId,\r\n    address indexed _owner,\r\n    address indexed _tokenAddress,\r\n    address _sidechainAddress,\r\n    uint32  _standard,\r\n    uint256 _tokenNumber // ERC-20 amount or ERC721 tokenId\r\n  );\r\n\r\n  event TokenWithdrew(\r\n    uint256 indexed _withdrawId,\r\n    address indexed _owner,\r\n    address indexed _tokenAddress,\r\n    uint256 _tokenNumber\r\n  );\r\n\r\n  struct DepositEntry {\r\n    address owner;\r\n    address tokenAddress;\r\n    address sidechainAddress;\r\n    uint32  standard;\r\n    uint256 tokenNumber;\r\n  }\r\n\r\n  struct WithdrawalEntry {\r\n    address owner;\r\n    address tokenAddress;\r\n    uint256 tokenNumber;\r\n  }\r\n\r\n  Registry public registry;\r\n\r\n  uint256 public depositCount;\r\n  DepositEntry[] public deposits;\r\n  mapping(uint256 => WithdrawalEntry) public withdrawals;\r\n\r\n  function updateRegistry(address _registry) external onlyAdmin {\r\n    registry = Registry(_registry);\r\n  }\r\n}\r\n\r\n// File: contracts/chain/mainchain/MainchainGatewayManager.sol\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title MainchainGatewayManager\r\n * @dev Logic to handle deposits and withdrawl on Mainchain.\r\n */\r\ncontract MainchainGatewayManager is MainchainGatewayStorage {\r\n  using AddressUtils for address;\r\n  using SafeMath for uint256;\r\n  using ECVerify for bytes32;\r\n\r\n  modifier onlyMappedToken(address _token, uint32 _standard) {\r\n    require(\r\n      registry.isTokenMapped(_token, _standard, true),\r\n      \"MainchainGatewayManager: Token is not mapped\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier onlyNewWithdrawal(uint256 _withdrawalId) {\r\n    WithdrawalEntry storage _entry = withdrawals[_withdrawalId];\r\n    require(_entry.owner == address(0) && _entry.tokenAddress == address(0));\r\n    _;\r\n  }\r\n\r\n  // Should be able to withdraw from WETH\r\n  function()\r\n    external\r\n    payable\r\n  {}\r\n\r\n  function depositEth()\r\n    external\r\n    whenNotPaused\r\n    payable\r\n    returns (uint256)\r\n  {\r\n    return depositEthFor(msg.sender);\r\n  }\r\n\r\n  function depositERC20(address _token, uint256 _amount)\r\n    external\r\n    whenNotPaused\r\n    returns (uint256)\r\n  {\r\n    return depositERC20For(msg.sender, _token, _amount);\r\n  }\r\n\r\n  function depositERC721(address _token, uint256 _tokenId)\r\n    external\r\n    whenNotPaused\r\n    returns (uint256)\r\n  {\r\n    return depositERC721For(msg.sender, _token, _tokenId);\r\n  }\r\n\r\n  function depositEthFor(address _owner)\r\n    public\r\n    whenNotPaused\r\n    payable\r\n    returns (uint256)\r\n  {\r\n    address _weth = registry.getContract(registry.WETH_TOKEN());\r\n    WETH(_weth).deposit.value(msg.value)();\r\n    return _createDepositEntry(_owner, _weth, 20, msg.value);\r\n  }\r\n\r\n  function depositERC20For(address _user, address _token, uint256 _amount)\r\n    public\r\n    whenNotPaused\r\n    returns (uint256)\r\n  {\r\n    require(\r\n      IERC20(_token).transferFrom(msg.sender, address(this), _amount),\r\n      \"MainchainGatewayManager: ERC-20 token transfer failed\"\r\n    );\r\n    return _createDepositEntry(_user, _token, 20, _amount);\r\n  }\r\n\r\n  function depositERC721For(address _user, address _token, uint256 _tokenId)\r\n    public\r\n    whenNotPaused\r\n    returns (uint256)\r\n  {\r\n    IERC721(_token).transferFrom(msg.sender, address(this), _tokenId);\r\n    return _createDepositEntry(_user, _token, 721, _tokenId);\r\n  }\r\n\r\n  function depositBulkFor(\r\n    address _user,\r\n    address[] memory _tokens,\r\n    uint256[] memory _tokenNumbers\r\n  )\r\n    public\r\n    whenNotPaused\r\n  {\r\n    require(_tokens.length == _tokenNumbers.length);\r\n\r\n    for (uint256 _i = 0; _i < _tokens.length; _i++) {\r\n      address _token = _tokens[_i];\r\n      uint256 _tokenNumber = _tokenNumbers[_i];\r\n      (,, uint32 _standard) = registry.getMappedToken(_token, true);\r\n\r\n      if (_standard == 20) {\r\n        depositERC20For(_user, _token, _tokenNumber);\r\n      } else if (_standard == 721) {\r\n        depositERC721For(_user, _token, _tokenNumber);\r\n      } else {\r\n        revert(\"Token is not mapped or token type not supported\");\r\n      }\r\n    }\r\n  }\r\n\r\n  function withdrawToken(\r\n    uint256 _withdrawalId,\r\n    address _token,\r\n    uint256 _amount,\r\n    bytes memory _signatures\r\n  )\r\n    public\r\n    whenNotPaused\r\n  {\r\n    withdrawTokenFor(\r\n      _withdrawalId,\r\n      msg.sender,\r\n      _token,\r\n      _amount,\r\n      _signatures\r\n    );\r\n  }\r\n\r\n  function withdrawTokenFor(\r\n    uint256 _withdrawalId,\r\n    address _user,\r\n    address _token,\r\n    uint256 _amount,\r\n    bytes memory _signatures\r\n  )\r\n    public\r\n    whenNotPaused\r\n  {\r\n    (,, uint32 _tokenType) = registry.getMappedToken(_token, true);\r\n\r\n    if (_tokenType == 20) {\r\n      withdrawERC20For(\r\n        _withdrawalId,\r\n        _user,\r\n        _token,\r\n        _amount,\r\n        _signatures\r\n      );\r\n    } else if (_tokenType == 721) {\r\n      withdrawERC721For(\r\n        _withdrawalId,\r\n        _user,\r\n        _token,\r\n        _amount,\r\n        _signatures\r\n      );\r\n    }\r\n  }\r\n\r\n  function withdrawERC20(\r\n    uint256 _withdrawalId,\r\n    address _token,\r\n    uint256 _amount,\r\n    bytes memory _signatures\r\n  )\r\n    public\r\n    whenNotPaused\r\n  {\r\n    withdrawERC20For(\r\n      _withdrawalId,\r\n      msg.sender,\r\n      _token,\r\n      _amount,\r\n      _signatures\r\n    );\r\n  }\r\n\r\n  function withdrawERC20For(\r\n    uint256 _withdrawalId,\r\n    address _user,\r\n    address _token,\r\n    uint256 _amount,\r\n    bytes memory _signatures\r\n  )\r\n    public\r\n    whenNotPaused\r\n    onlyMappedToken(_token, 20)\r\n  {\r\n    bytes32 _hash = keccak256(\r\n      abi.encodePacked(\r\n        \"withdrawERC20\",\r\n        _withdrawalId,\r\n        _user,\r\n        _token,\r\n        _amount\r\n      )\r\n    );\r\n\r\n    require(verifySignatures(_hash, _signatures));\r\n\r\n    if (_token == registry.getContract(registry.WETH_TOKEN())) {\r\n      _withdrawETHFor(_user, _amount);\r\n    } else {\r\n      uint256 _gatewayBalance = IERC20(_token).balanceOf(address(this));\r\n\r\n      if (_gatewayBalance < _amount) {\r\n        require(\r\n          IERC20Mintable(_token).mint(address(this), _amount.sub(_gatewayBalance)),\r\n          \"MainchainGatewayManager: Minting ERC20 token to gateway failed\"\r\n        );\r\n      }\r\n\r\n      require(IERC20(_token).transfer(_user, _amount), \"Transfer failed\");\r\n    }\r\n\r\n    _insertWithdrawalEntry(\r\n      _withdrawalId,\r\n      _user,\r\n      _token,\r\n      _amount\r\n    );\r\n  }\r\n\r\n  function withdrawERC721(\r\n    uint256 _withdrawalId,\r\n    address _token,\r\n    uint256 _tokenId,\r\n    bytes memory _signatures\r\n  )\r\n    public\r\n    whenNotPaused\r\n  {\r\n    withdrawERC721For(\r\n      _withdrawalId,\r\n      msg.sender,\r\n      _token,\r\n      _tokenId,\r\n      _signatures\r\n    );\r\n  }\r\n\r\n  function withdrawERC721For(\r\n    uint256 _withdrawalId,\r\n    address _user,\r\n    address _token,\r\n    uint256 _tokenId,\r\n    bytes memory _signatures\r\n  )\r\n    public\r\n    whenNotPaused\r\n    onlyMappedToken(_token, 721)\r\n  {\r\n    bytes32 _hash = keccak256(\r\n      abi.encodePacked(\r\n        \"withdrawERC721\",\r\n        _withdrawalId,\r\n        _user,\r\n        _token,\r\n        _tokenId\r\n      )\r\n    );\r\n\r\n    require(verifySignatures(_hash, _signatures));\r\n\r\n    if (!_tryERC721TransferFrom(_token, address(this), _user, _tokenId)) {\r\n      require(\r\n        IERC721Mintable(_token).mint(_user, _tokenId),\r\n        \"MainchainGatewayManager: Minting ERC721 token to gateway failed\"\r\n      );\r\n    }\r\n\r\n    _insertWithdrawalEntry(_withdrawalId, _user, _token, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev returns true if there is enough signatures from validators.\r\n   */\r\n  function verifySignatures(\r\n    bytes32 _hash,\r\n    bytes memory _signatures\r\n  )\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    uint256 _signatureCount = _signatures.length.div(66);\r\n\r\n    Validator _validator = Validator(registry.getContract(registry.VALIDATOR()));\r\n    uint256 _validatorCount = 0;\r\n    address _lastSigner = address(0);\r\n\r\n    for (uint256 i = 0; i < _signatureCount; i++) {\r\n      address _signer = _hash.recover(_signatures, i.mul(66));\r\n      if (_validator.isValidator(_signer)) {\r\n        _validatorCount++;\r\n      }\r\n      // Prevent duplication of signatures\r\n      require(_signer > _lastSigner);\r\n      _lastSigner = _signer;\r\n    }\r\n\r\n    return _validator.checkThreshold(_validatorCount);\r\n  }\r\n\r\n  function _createDepositEntry(\r\n    address _owner,\r\n    address _token,\r\n    uint32 _standard,\r\n    uint256 _number\r\n  )\r\n    internal\r\n    onlyMappedToken(_token, _standard)\r\n    returns (uint256 _depositId)\r\n  {\r\n    (,address _sidechainToken, uint32 _tokenStandard) = registry.getMappedToken(_token, true);\r\n    require(_standard == _tokenStandard);\r\n\r\n    DepositEntry memory _entry = DepositEntry(\r\n      _owner,\r\n      _token,\r\n      _sidechainToken,\r\n      _standard,\r\n      _number\r\n    );\r\n\r\n    deposits.push(_entry);\r\n    _depositId = depositCount++;\r\n\r\n    emit TokenDeposited(\r\n      _depositId,\r\n      _owner,\r\n      _token,\r\n      _sidechainToken,\r\n      _standard,\r\n      _number\r\n    );\r\n  }\r\n\r\n  function _insertWithdrawalEntry(\r\n    uint256 _withdrawalId,\r\n    address _owner,\r\n    address _token,\r\n    uint256 _number\r\n  )\r\n    internal\r\n    onlyNewWithdrawal(_withdrawalId)\r\n  {\r\n    WithdrawalEntry memory _entry = WithdrawalEntry(\r\n      _owner,\r\n      _token,\r\n      _number\r\n    );\r\n\r\n    withdrawals[_withdrawalId] = _entry;\r\n\r\n    emit TokenWithdrew(_withdrawalId, _owner, _token, _number);\r\n  }\r\n\r\n  function _withdrawETHFor(\r\n    address _user,\r\n    uint256 _amount\r\n  )\r\n    internal\r\n  {\r\n    address _weth = registry.getContract(registry.WETH_TOKEN());\r\n    WETH(_weth).withdraw(_amount);\r\n    _user.toPayable().transfer(_amount);\r\n  }\r\n\r\n  // See more here https://blog.polymath.network/try-catch-in-solidity-handling-the-revert-exception-f53718f76047\r\n  function _tryERC721TransferFrom(\r\n    address _token,\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    returns (bool)\r\n  {\r\n    (bool success,) = _token.call(\r\n      abi.encodeWithSelector(\r\n        IERC721(_token).transferFrom.selector, _from, _to, _tokenId\r\n      )\r\n    );\r\n    return success;\r\n  }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_oldAdmin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_oldAdmin\",\"type\":\"address\"}],\"name\":\"AdminRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_depositId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sidechainAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_standard\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenNumber\",\"type\":\"uint256\"}],\"name\":\"TokenDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_withdrawId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenNumber\",\"type\":\"uint256\"}],\"name\":\"TokenWithdrew\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpaused\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenNumbers\",\"type\":\"uint256[]\"}],\"name\":\"depositBulkFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositERC20\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositERC20For\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"depositERC721\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"depositERC721For\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"depositEthFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sidechainAddress\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"standard\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"tokenNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract Registry\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"}],\"name\":\"updateRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signatures\",\"type\":\"bytes\"}],\"name\":\"verifySignatures\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_withdrawalId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signatures\",\"type\":\"bytes\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_withdrawalId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signatures\",\"type\":\"bytes\"}],\"name\":\"withdrawERC20For\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_withdrawalId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signatures\",\"type\":\"bytes\"}],\"name\":\"withdrawERC721\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_withdrawalId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signatures\",\"type\":\"bytes\"}],\"name\":\"withdrawERC721For\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_withdrawalId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signatures\",\"type\":\"bytes\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_withdrawalId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signatures\",\"type\":\"bytes\"}],\"name\":\"withdrawTokenFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"withdrawals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MainchainGatewayManager", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://29d3448421279dd0d60222ed01650f8f655c2a56f9e21df340b52d2d8baff0bb"}