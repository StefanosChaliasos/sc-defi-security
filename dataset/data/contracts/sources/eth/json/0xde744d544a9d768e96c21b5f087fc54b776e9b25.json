{"SourceCode": "/**\r\n * Copyright 2017-2020, bZeroX, LLC <https://bzx.network/>. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0.\r\n */\r\n\r\npragma solidity 0.5.17;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ninterface IWeth {\r\n    function deposit() external payable;\r\n    function withdraw(uint256 wad) external;\r\n}\r\n\r\ncontract IERC20 {\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address _who) public view returns (uint256);\r\n    function allowance(address _owner, address _spender) public view returns (uint256);\r\n    function approve(address _spender, uint256 _value) public returns (bool);\r\n    function transfer(address _to, uint256 _value) public returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract IWethERC20 is IWeth, IERC20 {}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b != 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, rounding up and truncating the quotient\r\n    */\r\n    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return divCeil(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, rounding up and truncating the quotient\r\n    */\r\n    function divCeil(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b != 0, errorMessage);\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = ((a - 1) / b) + 1;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    function min256(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        return _a < _b ? _a : _b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SignedSafeMath\r\n * @dev Signed math operations with safety checks that revert on error.\r\n */\r\nlibrary SignedSafeMath {\r\n    int256 constant private _INT256_MIN = -2**255;\r\n\r\n        /**\r\n     * @dev Returns the multiplication of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two signed integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0, \"SignedSafeMath: division by zero\");\r\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2\u03c0.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n    /// @dev Constant for unlocked guard state - non-zero to prevent extra gas costs.\r\n    /// See: https://github.com/OpenZeppelin/openzeppelin-solidity/issues/1056\r\n    uint256 internal constant REENTRANCY_GUARD_FREE = 1;\r\n\r\n    /// @dev Constant for locked guard state\r\n    uint256 internal constant REENTRANCY_GUARD_LOCKED = 2;\r\n\r\n    /**\r\n    * @dev We use a single lock for the whole contract.\r\n    */\r\n    uint256 internal reentrancyLock = REENTRANCY_GUARD_FREE;\r\n\r\n    /**\r\n    * @dev Prevents a contract from calling itself, directly or indirectly.\r\n    * If you mark a function `nonReentrant`, you should also\r\n    * mark it `external`. Calling one `nonReentrant` function from\r\n    * another is not supported. Instead, you can implement a\r\n    * `private` function doing the actual work, and an `external`\r\n    * wrapper marked as `nonReentrant`.\r\n    */\r\n    modifier nonReentrant() {\r\n        require(reentrancyLock == REENTRANCY_GUARD_FREE, \"nonReentrant\");\r\n        reentrancyLock = REENTRANCY_GUARD_LOCKED;\r\n        _;\r\n        reentrancyLock = REENTRANCY_GUARD_FREE;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following \r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"unauthorized\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface ProtocolLike {\r\n    function borrowOrTradeFromPool(\r\n        bytes32 loanParamsId,\r\n        bytes32 loanId, // if 0, start a new loan\r\n        bool isTorqueLoan,\r\n        uint256 initialMargin,\r\n        address[4] calldata sentAddresses,\r\n            // lender: must match loan if loanId provided\r\n            // borrower: must match loan if loanId provided\r\n            // receiver: receiver of funds (address(0) assumes borrower address)\r\n            // manager: delegated manager of loan unless address(0)\r\n        uint256[5] calldata sentValues,\r\n            // newRate: new loan interest rate\r\n            // newPrincipal: new loan size (borrowAmount + any borrowed interest)\r\n            // torqueInterest: new amount of interest to escrow for Torque loan (determines initial loan length)\r\n            // loanTokenReceived: total loanToken deposit (amount not sent to borrower in the case of Torque loans)\r\n            // collateralTokenReceived: total collateralToken deposit\r\n        bytes calldata loanDataBytes)\r\n        external\r\n        payable\r\n        returns (uint256 newPrincipal, uint256 newCollateral);\r\n\r\n    function getTotalPrincipal(\r\n        address lender,\r\n        address loanToken)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function withdrawAccruedInterest(\r\n        address loanToken)\r\n        external;\r\n\r\n    function getLenderInterestData(\r\n        address lender,\r\n        address loanToken)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 interestPaid,\r\n            uint256 interestPaidDate,\r\n            uint256 interestOwedPerDay,\r\n            uint256 interestUnPaid,\r\n            uint256 interestFeePercent,\r\n            uint256 principalTotal);\r\n\r\n    function priceFeeds()\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function getEstimatedMarginExposure(\r\n        address loanToken,\r\n        address collateralToken,\r\n        uint256 loanTokenSent,\r\n        uint256 collateralTokenSent,\r\n        uint256 interestRate,\r\n        uint256 newPrincipal)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getRequiredCollateralByParams(\r\n        bytes32 loanParamsId,\r\n        address loanToken,\r\n        address collateralToken,\r\n        uint256 newPrincipal,\r\n        bool isTorqueLoan)\r\n        external\r\n        view\r\n        returns (uint256 collateralAmountRequired);\r\n\r\n    function getBorrowAmountByParams(\r\n        bytes32 loanParamsId,\r\n        address loanToken,\r\n        address collateralToken,\r\n        uint256 collateralTokenAmount,\r\n        bool isTorqueLoan)\r\n        external\r\n        view\r\n        returns (uint256 borrowAmount);\r\n\r\n    function isLoanPool(\r\n        address loanPool)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function lendingFeePercent()\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\ninterface FeedsLike {\r\n    function queryRate(\r\n        address sourceTokenAddress,\r\n        address destTokenAddress)\r\n        external\r\n        view\r\n        returns (uint256 rate, uint256 precision);\r\n}\r\n\r\ncontract ITokenHolderLike {\r\n    function balanceOf(address _who) public view returns (uint256);\r\n    function freeUpTo(uint256 value) public returns (uint256);\r\n    function freeFromUpTo(address from, uint256 value) public returns (uint256);\r\n}\r\n\r\ncontract GasTokenUser {\r\n\r\n    ITokenHolderLike constant public gasToken = ITokenHolderLike(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\r\n    ITokenHolderLike constant public tokenHolder = ITokenHolderLike(0x55Eb3DD3f738cfdda986B8Eff3fa784477552C61);\r\n\r\n    modifier usesGasToken(address holder) {\r\n        if (holder == address(0)) {\r\n            holder = address(tokenHolder);\r\n        }\r\n\r\n        if (gasToken.balanceOf(holder) != 0) {\r\n            uint256 gasCalcValue = gasleft();\r\n\r\n            _;\r\n\r\n            gasCalcValue = (_gasUsed(gasCalcValue) + 14154) / 41947;\r\n\r\n            if (holder == address(tokenHolder)) {\r\n                tokenHolder.freeUpTo(\r\n                    gasCalcValue\r\n                );\r\n            } else {\r\n                tokenHolder.freeFromUpTo(\r\n                    holder,\r\n                    gasCalcValue\r\n                );\r\n            }\r\n\r\n        } else {\r\n            _;\r\n        }\r\n    }\r\n\r\n    function _gasUsed(\r\n        uint256 startingGas)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return 21000 +\r\n            startingGas -\r\n            gasleft() +\r\n            16 *\r\n            msg.data.length;\r\n\r\n    }\r\n}\r\n\r\ncontract Pausable {\r\n\r\n    // keccak256(\"Pausable_FunctionPause\")\r\n    bytes32 internal constant Pausable_FunctionPause = 0xa7143c84d793a15503da6f19bf9119a2dac94448ca45d77c8bf08f57b2e91047;\r\n\r\n    modifier pausable(bytes4 sig) {\r\n        require(!_isPaused(sig), \"unauthorized\");\r\n        _;\r\n    }\r\n\r\n    function _isPaused(\r\n        bytes4 sig)\r\n        internal\r\n        view\r\n        returns (bool isPaused)\r\n    {\r\n        bytes32 slot = keccak256(abi.encodePacked(sig, Pausable_FunctionPause));\r\n        assembly {\r\n            isPaused := sload(slot)\r\n        }\r\n    }\r\n}\r\n\r\ncontract LoanTokenBase is ReentrancyGuard, Ownable, Pausable {\r\n\r\n    uint256 internal constant WEI_PRECISION = 10**18;\r\n    uint256 internal constant WEI_PERCENT_PRECISION = 10**20;\r\n\r\n    int256 internal constant sWEI_PRECISION = 10**18;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    // uint88 for tight packing -> 8 + 88 + 160 = 256\r\n    uint88 internal lastSettleTime_;\r\n\r\n    address public loanTokenAddress;\r\n\r\n    uint256 public baseRate;\r\n    uint256 public rateMultiplier;\r\n    uint256 public lowUtilBaseRate;\r\n    uint256 public lowUtilRateMultiplier;\r\n\r\n    uint256 public targetLevel;\r\n    uint256 public kinkLevel;\r\n    uint256 public maxScaleRate;\r\n\r\n    uint256 internal _flTotalAssetSupply;\r\n    uint256 public checkpointSupply;\r\n    uint256 public initialPrice;\r\n\r\n    mapping (uint256 => bytes32) public loanParamsIds; // mapping of keccak256(collateralToken, isTorqueLoan) to loanParamsId\r\n    mapping (address => uint256) internal checkpointPrices_; // price of token at last user checkpoint\r\n}\r\n\r\ncontract AdvancedTokenStorage is LoanTokenBase {\r\n    using SafeMath for uint256;\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    event Mint(\r\n        address indexed minter,\r\n        uint256 tokenAmount,\r\n        uint256 assetAmount,\r\n        uint256 price\r\n    );\r\n\r\n    event Burn(\r\n        address indexed burner,\r\n        uint256 tokenAmount,\r\n        uint256 assetAmount,\r\n        uint256 price\r\n    );\r\n\r\n    mapping(address => uint256) internal balances;\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n    uint256 internal totalSupply_;\r\n\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return totalSupply_;\r\n    }\r\n\r\n    function balanceOf(\r\n        address _owner)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function allowance(\r\n        address _owner,\r\n        address _spender)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\ncontract AdvancedToken is AdvancedTokenStorage {\r\n    using SafeMath for uint256;\r\n\r\n    function approve(\r\n        address _spender,\r\n        uint256 _value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval(\r\n        address _spender,\r\n        uint256 _addedValue)\r\n        public\r\n        returns (bool)\r\n    {\r\n        uint256 _allowed = allowed[msg.sender][_spender]\r\n            .add(_addedValue);\r\n        allowed[msg.sender][_spender] = _allowed;\r\n\r\n        emit Approval(msg.sender, _spender, _allowed);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(\r\n        address _spender,\r\n        uint256 _subtractedValue)\r\n        public\r\n        returns (bool)\r\n    {\r\n        uint256 _allowed = allowed[msg.sender][_spender];\r\n        if (_subtractedValue >= _allowed) {\r\n            _allowed = 0;\r\n        } else {\r\n            _allowed -= _subtractedValue;\r\n        }\r\n        allowed[msg.sender][_spender] = _allowed;\r\n\r\n        emit Approval(msg.sender, _spender, _allowed);\r\n        return true;\r\n    }\r\n\r\n    function _mint(\r\n        address _to,\r\n        uint256 _tokenAmount,\r\n        uint256 _assetAmount,\r\n        uint256 _price)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        require(_to != address(0), \"15\");\r\n\r\n        uint256 _balance = balances[_to]\r\n            .add(_tokenAmount);\r\n        balances[_to] = _balance;\r\n\r\n        totalSupply_ = totalSupply_\r\n            .add(_tokenAmount);\r\n\r\n        emit Mint(_to, _tokenAmount, _assetAmount, _price);\r\n        emit Transfer(address(0), _to, _tokenAmount);\r\n\r\n        return _balance;\r\n    }\r\n\r\n    function _burn(\r\n        address _who,\r\n        uint256 _tokenAmount,\r\n        uint256 _assetAmount,\r\n        uint256 _price)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        uint256 _balance = balances[_who].sub(_tokenAmount, \"16\");\r\n        \r\n        // a rounding error may leave dust behind, so we clear this out\r\n        if (_balance <= 10) {\r\n            _tokenAmount = _tokenAmount.add(_balance);\r\n            _balance = 0;\r\n        }\r\n        balances[_who] = _balance;\r\n\r\n        totalSupply_ = totalSupply_.sub(_tokenAmount);\r\n\r\n        emit Burn(_who, _tokenAmount, _assetAmount, _price);\r\n        emit Transfer(_who, address(0), _tokenAmount);\r\n\r\n        return _balance;\r\n    }\r\n}\r\n\r\ncontract LoanTokenLogicStandard is AdvancedToken, GasTokenUser {\r\n    using SafeMath for uint256;\r\n    using SignedSafeMath for int256;\r\n\r\n    modifier settlesInterest() {\r\n        _settleInterest();\r\n        _;\r\n    }\r\n\r\n    address internal target_;\r\n\r\n    uint256 public constant VERSION = 6;\r\n    address internal constant arbitraryCaller = 0x000F400e6818158D541C3EBE45FE3AA0d47372FF;\r\n\r\n    address public constant bZxContract = 0xD8Ee69652E4e4838f2531732a46d1f7F584F0b7f;\r\n    address public constant wethToken = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n\r\n    bytes32 internal constant iToken_ProfitSoFar = 0x37aa2b7d583612f016e4a4de4292cb015139b3d7762663d06a53964912ea2fb6;          // keccak256(\"iToken_ProfitSoFar\")\r\n    bytes32 internal constant iToken_LowerAdminAddress = 0x7ad06df6a0af6bd602d90db766e0d5f253b45187c3717a0f9026ea8b10ff0d4b;    // keccak256(\"iToken_LowerAdminAddress\")\r\n    bytes32 internal constant iToken_LowerAdminContract = 0x34b31cff1dbd8374124bd4505521fc29cab0f9554a5386ba7d784a4e611c7e31;   // keccak256(\"iToken_LowerAdminContract\")\r\n\r\n\r\n    constructor(\r\n        address _newOwner)\r\n        public\r\n    {\r\n        transferOwnership(_newOwner);\r\n    }\r\n\r\n    function()\r\n        external\r\n    {\r\n        revert(\"fallback not allowed\");\r\n    }\r\n\r\n    /* Public functions */\r\n\r\n    function mint(\r\n        address receiver,\r\n        uint256 depositAmount)\r\n        external\r\n        nonReentrant\r\n        returns (uint256) // mintAmount\r\n    {\r\n        return _mintToken(\r\n            receiver,\r\n            depositAmount\r\n        );\r\n    }\r\n\r\n    function burn(\r\n        address receiver,\r\n        uint256 burnAmount)\r\n        external\r\n        nonReentrant\r\n        returns (uint256 loanAmountPaid)\r\n    {\r\n        loanAmountPaid = _burnToken(\r\n            burnAmount\r\n        );\r\n\r\n        if (loanAmountPaid != 0) {\r\n            _safeTransfer(loanTokenAddress, receiver, loanAmountPaid, \"5\");\r\n        }\r\n    }\r\n\r\n    function flashBorrow(\r\n        uint256 borrowAmount,\r\n        address borrower,\r\n        address target,\r\n        string calldata signature,\r\n        bytes calldata data)\r\n        external\r\n        payable\r\n        nonReentrant\r\n        pausable(msg.sig)\r\n        settlesInterest\r\n        returns (bytes memory)\r\n    {\r\n        require(borrowAmount != 0, \"38\");\r\n\r\n        // save before balances\r\n        uint256 beforeEtherBalance = address(this).balance.sub(msg.value);\r\n        uint256 beforeAssetsBalance = _underlyingBalance()\r\n            .add(totalAssetBorrow());\r\n\r\n        // lock totalAssetSupply for duration of flash loan\r\n        _flTotalAssetSupply = beforeAssetsBalance;\r\n\r\n        // transfer assets to calling contract\r\n        _safeTransfer(loanTokenAddress, borrower, borrowAmount, \"39\");\r\n\r\n        bytes memory callData;\r\n        if (bytes(signature).length == 0) {\r\n            callData = data;\r\n        } else {\r\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\r\n        }\r\n\r\n        // arbitrary call\r\n        (bool success, bytes memory returnData) = arbitraryCaller.call.value(msg.value)(\r\n            abi.encodeWithSelector(\r\n                0xde064e0d, // sendCall(address,bytes)\r\n                target,\r\n                callData\r\n            )\r\n        );\r\n        require(success, \"call failed\");\r\n\r\n        // unlock totalAssetSupply\r\n        _flTotalAssetSupply = 0;\r\n\r\n        // verifies return of flash loan\r\n        require(\r\n            address(this).balance >= beforeEtherBalance &&\r\n            _underlyingBalance()\r\n                .add(totalAssetBorrow()) >= beforeAssetsBalance,\r\n            \"40\"\r\n        );\r\n\r\n        return returnData;\r\n    }\r\n\r\n    // ***** NOTE: Reentrancy is allowed here to allow flashloan use cases *****\r\n    function borrow(\r\n        bytes32 loanId,                 // 0 if new loan\r\n        uint256 withdrawAmount,\r\n        uint256 initialLoanDuration,    // duration in seconds\r\n        uint256 collateralTokenSent,    // if 0, loanId must be provided; any ETH sent must equal this value\r\n        address collateralTokenAddress, // if address(0), this means ETH and ETH must be sent with the call or loanId must be provided\r\n        address borrower,\r\n        address receiver,\r\n        bytes memory /*loanDataBytes*/) // arbitrary order data (for future use)\r\n        public\r\n        payable\r\n        returns (uint256, uint256) // returns new principal and new collateral added to loan\r\n    {\r\n        return _borrow(\r\n            loanId,\r\n            withdrawAmount,\r\n            initialLoanDuration,\r\n            collateralTokenSent,\r\n            collateralTokenAddress,\r\n            borrower,\r\n            receiver,\r\n            \"\"\r\n        );\r\n    }\r\n\r\n    // ***** NOTE: Reentrancy is allowed here to allow flashloan use cases *****\r\n    function borrowWithGasToken(\r\n        bytes32 loanId,                 // 0 if new loan\r\n        uint256 withdrawAmount,\r\n        uint256 initialLoanDuration,    // duration in seconds\r\n        uint256 collateralTokenSent,    // if 0, loanId must be provided; any ETH sent must equal this value\r\n        address collateralTokenAddress, // if address(0), this means ETH and ETH must be sent with the call or loanId must be provided\r\n        address borrower,\r\n        address receiver,\r\n        address gasTokenUser,           // specifies an address that has given spend approval for gas/chi token\r\n        bytes memory /*loanDataBytes*/) // arbitrary order data (for future use)\r\n        public\r\n        payable\r\n        usesGasToken(gasTokenUser)\r\n        returns (uint256, uint256) // returns new principal and new collateral added to loan\r\n    {\r\n        return _borrow(\r\n            loanId,\r\n            withdrawAmount,\r\n            initialLoanDuration,\r\n            collateralTokenSent,\r\n            collateralTokenAddress,\r\n            borrower,\r\n            receiver,\r\n            \"\"\r\n        );\r\n    }\r\n\r\n    // Called to borrow and immediately get into a position\r\n    // ***** NOTE: Reentrancy is allowed here to allow flashloan use cases *****\r\n    function marginTrade(\r\n        bytes32 loanId,                 // 0 if new loan\r\n        uint256 leverageAmount,\r\n        uint256 loanTokenSent,\r\n        uint256 collateralTokenSent,\r\n        address collateralTokenAddress,\r\n        address trader,\r\n        bytes memory loanDataBytes)     // arbitrary order data\r\n        public\r\n        payable\r\n        returns (uint256, uint256) // returns new principal and new collateral added to trade\r\n    {\r\n        return _marginTrade(\r\n            loanId,\r\n            leverageAmount,\r\n            loanTokenSent,\r\n            collateralTokenSent,\r\n            collateralTokenAddress,\r\n            trader,\r\n            loanDataBytes\r\n        );\r\n    }\r\n\r\n    // Called to borrow and immediately get into a position\r\n    // ***** NOTE: Reentrancy is allowed here to allow flashloan use cases *****\r\n    function marginTradeWithGasToken(\r\n        bytes32 loanId,                 // 0 if new loan\r\n        uint256 leverageAmount,\r\n        uint256 loanTokenSent,\r\n        uint256 collateralTokenSent,\r\n        address collateralTokenAddress,\r\n        address trader,\r\n        address gasTokenUser,           // specifies an address that has given spend approval for gas/chi token\r\n        bytes memory loanDataBytes)     // arbitrary order data\r\n        public\r\n        payable\r\n        usesGasToken(gasTokenUser)\r\n        returns (uint256, uint256) // returns new principal and new collateral added to trade\r\n    {\r\n        return _marginTrade(\r\n            loanId,\r\n            leverageAmount,\r\n            loanTokenSent,\r\n            collateralTokenSent,\r\n            collateralTokenAddress,\r\n            trader,\r\n            loanDataBytes\r\n        );\r\n    }\r\n\r\n    function transfer(\r\n        address _to,\r\n        uint256 _value)\r\n        external\r\n        returns (bool)\r\n    {\r\n        return _internalTransferFrom(\r\n            msg.sender,\r\n            _to,\r\n            _value,\r\n            uint256(-1)\r\n        );\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value)\r\n        external\r\n        returns (bool)\r\n    {\r\n        return _internalTransferFrom(\r\n            _from,\r\n            _to,\r\n            _value,\r\n            allowed[_from][msg.sender]\r\n            /*ProtocolLike(bZxContract).isLoanPool(msg.sender) ?\r\n                uint256(-1) :\r\n                allowed[_from][msg.sender]*/\r\n        );\r\n    }\r\n\r\n    function _internalTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _allowanceAmount)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        if (_allowanceAmount != uint256(-1)) {\r\n            allowed[_from][msg.sender] = _allowanceAmount.sub(_value, \"14\");\r\n        }\r\n\r\n        uint256 _balancesFrom = balances[_from];\r\n        uint256 _balancesTo = balances[_to];\r\n\r\n        require(_to != address(0), \"15\");\r\n\r\n        uint256 _balancesFromNew = _balancesFrom\r\n            .sub(_value, \"16\");\r\n        balances[_from] = _balancesFromNew;\r\n\r\n        uint256 _balancesToNew = _balancesTo\r\n            .add(_value);\r\n        balances[_to] = _balancesToNew;\r\n\r\n        // handle checkpoint update\r\n        uint256 _currentPrice = tokenPrice();\r\n\r\n        _updateCheckpoints(\r\n            _from,\r\n            _balancesFrom,\r\n            _balancesFromNew,\r\n            _currentPrice\r\n        );\r\n        _updateCheckpoints(\r\n            _to,\r\n            _balancesTo,\r\n            _balancesToNew,\r\n            _currentPrice\r\n        );\r\n\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function _updateCheckpoints(\r\n        address _user,\r\n        uint256 _oldBalance,\r\n        uint256 _newBalance,\r\n        uint256 _currentPrice)\r\n        internal\r\n    {\r\n        bytes32 slot = keccak256(\r\n            abi.encodePacked(_user, iToken_ProfitSoFar)\r\n        );\r\n\r\n        int256 _currentProfit;\r\n        if (_newBalance == 0) {\r\n            _currentPrice = 0;\r\n        } else if (_oldBalance != 0) {\r\n            _currentProfit = _profitOf(\r\n                slot,\r\n                _oldBalance,\r\n                _currentPrice,\r\n                checkpointPrices_[_user]\r\n            );\r\n        }\r\n\r\n        assembly {\r\n            sstore(slot, _currentProfit)\r\n        }\r\n\r\n        checkpointPrices_[_user] = _currentPrice;\r\n    }\r\n\r\n    /* Public View functions */\r\n\r\n    function profitOf(\r\n        address user)\r\n        public\r\n        view\r\n        returns (int256)\r\n    {\r\n        bytes32 slot = keccak256(\r\n            abi.encodePacked(user, iToken_ProfitSoFar)\r\n        );\r\n\r\n        return _profitOf(\r\n            slot,\r\n            balances[user],\r\n            tokenPrice(),\r\n            checkpointPrices_[user]\r\n        );\r\n    }\r\n\r\n    function _profitOf(\r\n        bytes32 slot,\r\n        uint256 _balance,\r\n        uint256 _currentPrice,\r\n        uint256 _checkpointPrice)\r\n        internal\r\n        view\r\n        returns (int256 profitSoFar)\r\n    {\r\n        if (_checkpointPrice == 0) {\r\n            return 0;\r\n        }\r\n\r\n        assembly {\r\n            profitSoFar := sload(slot)\r\n        }\r\n\r\n        profitSoFar = int256(_currentPrice)\r\n            .sub(int256(_checkpointPrice))\r\n            .mul(int256(_balance))\r\n            .div(sWEI_PRECISION)\r\n            .add(profitSoFar);\r\n    }\r\n\r\n    function tokenPrice()\r\n        public\r\n        view\r\n        returns (uint256) // price\r\n    {\r\n        uint256 interestUnPaid;\r\n        if (lastSettleTime_ != uint88(block.timestamp)) {\r\n            (,interestUnPaid) = _getAllInterest();\r\n        }\r\n\r\n        return _tokenPrice(_totalAssetSupply(interestUnPaid));\r\n    }\r\n\r\n    function checkpointPrice(\r\n        address _user)\r\n        public\r\n        view\r\n        returns (uint256) // price\r\n    {\r\n        return checkpointPrices_[_user];\r\n    }\r\n\r\n    function marketLiquidity()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 totalSupply = _totalAssetSupply(0);\r\n        uint256 totalBorrow = totalAssetBorrow();\r\n        if (totalSupply > totalBorrow) {\r\n            return totalSupply - totalBorrow;\r\n        }\r\n    }\r\n\r\n    function avgBorrowInterestRate()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _avgBorrowInterestRate(totalAssetBorrow());\r\n    }\r\n\r\n    // the minimum rate the next base protocol borrower will receive for variable-rate loans\r\n    function borrowInterestRate()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _nextBorrowInterestRate(0);\r\n    }\r\n\r\n    function nextBorrowInterestRate(\r\n        uint256 borrowAmount)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _nextBorrowInterestRate(borrowAmount);\r\n    }\r\n\r\n    // interest that lenders are currently receiving when supplying to the pool\r\n    function supplyInterestRate()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return totalSupplyInterestRate(_totalAssetSupply(0));\r\n    }\r\n\r\n    function nextSupplyInterestRate(\r\n        uint256 supplyAmount)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return totalSupplyInterestRate(_totalAssetSupply(0).add(supplyAmount));\r\n    }\r\n\r\n    function totalSupplyInterestRate(\r\n        uint256 assetSupply)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 assetBorrow = totalAssetBorrow();\r\n        if (assetBorrow != 0) {\r\n            return _supplyInterestRate(\r\n                assetBorrow,\r\n                assetSupply\r\n            );\r\n        }\r\n    }\r\n\r\n    function totalAssetBorrow()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return ProtocolLike(bZxContract).getTotalPrincipal(\r\n            address(this),\r\n            loanTokenAddress\r\n        );\r\n    }\r\n\r\n    function totalAssetSupply()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 interestUnPaid;\r\n        if (lastSettleTime_ != uint88(block.timestamp)) {\r\n            (,interestUnPaid) = _getAllInterest();\r\n        }\r\n\r\n        return _totalAssetSupply(interestUnPaid);\r\n    }\r\n\r\n    function getMaxEscrowAmount(\r\n        uint256 leverageAmount)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 initialMargin = SafeMath.div(WEI_PRECISION * WEI_PERCENT_PRECISION, leverageAmount);\r\n        return marketLiquidity()\r\n            .mul(initialMargin)\r\n            .div(_adjustValue(\r\n                WEI_PERCENT_PRECISION, // maximum possible interest (100%)\r\n                2419200, // 28 day duration for margin trades\r\n                initialMargin));\r\n    }\r\n\r\n    // returns the user's balance of underlying token\r\n    function assetBalanceOf(\r\n        address _owner)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return balanceOf(_owner)\r\n            .mul(tokenPrice())\r\n            .div(WEI_PRECISION);\r\n    }\r\n\r\n    function getEstimatedMarginDetails(\r\n        uint256 leverageAmount,\r\n        uint256 loanTokenSent,\r\n        uint256 collateralTokenSent,\r\n        address collateralTokenAddress)     // address(0) means ETH\r\n        public\r\n        view\r\n        returns (uint256 principal, uint256 collateral, uint256 interestRate)\r\n    {\r\n        if (collateralTokenAddress == address(0)) {\r\n            collateralTokenAddress = wethToken;\r\n        }\r\n\r\n        uint256 totalDeposit = _totalDeposit(\r\n            collateralTokenAddress,\r\n            collateralTokenSent,\r\n            loanTokenSent\r\n        );\r\n\r\n        (principal, interestRate) = _getMarginBorrowAmountAndRate(\r\n            leverageAmount,\r\n            totalDeposit\r\n        );\r\n        if (principal > _underlyingBalance()) {\r\n            return (0, 0, 0);\r\n        }\r\n\r\n        loanTokenSent = loanTokenSent\r\n            .add(principal);\r\n\r\n        collateral = ProtocolLike(bZxContract).getEstimatedMarginExposure(\r\n            loanTokenAddress,\r\n            collateralTokenAddress,\r\n            loanTokenSent,\r\n            collateralTokenSent,\r\n            interestRate,\r\n            principal\r\n        );\r\n    }\r\n\r\n    function getDepositAmountForBorrow(\r\n        uint256 borrowAmount,\r\n        uint256 initialLoanDuration,        // duration in seconds\r\n        address collateralTokenAddress)     // address(0) means ETH\r\n        public\r\n        view\r\n        returns (uint256) // depositAmount\r\n    {\r\n        if (borrowAmount != 0) {\r\n            (,,uint256 newBorrowAmount) = _getInterestRateAndBorrowAmount(\r\n                borrowAmount,\r\n                totalAssetSupply(),\r\n                initialLoanDuration\r\n            );\r\n\r\n            if (newBorrowAmount <= _underlyingBalance()) {\r\n                return ProtocolLike(bZxContract).getRequiredCollateralByParams(\r\n                    loanParamsIds[uint256(keccak256(abi.encodePacked(\r\n                        collateralTokenAddress,\r\n                        true\r\n                    )))],\r\n                    loanTokenAddress,\r\n                    collateralTokenAddress != address(0) ? collateralTokenAddress : wethToken,\r\n                    newBorrowAmount,\r\n                    true // isTorqueLoan\r\n                ).add(10); // some dust to compensate for rounding errors\r\n            }\r\n        }\r\n    }\r\n\r\n    function getBorrowAmountForDeposit(\r\n        uint256 depositAmount,\r\n        uint256 initialLoanDuration,        // duration in seconds\r\n        address collateralTokenAddress)     // address(0) means ETH\r\n        public\r\n        view\r\n        returns (uint256 borrowAmount)\r\n    {\r\n        if (depositAmount != 0) {\r\n            borrowAmount = ProtocolLike(bZxContract).getBorrowAmountByParams(\r\n                loanParamsIds[uint256(keccak256(abi.encodePacked(\r\n                    collateralTokenAddress,\r\n                    true\r\n                )))],\r\n                loanTokenAddress,\r\n                collateralTokenAddress != address(0) ? collateralTokenAddress : wethToken,\r\n                depositAmount,\r\n                true // isTorqueLoan\r\n            );\r\n\r\n            (,,borrowAmount) = _getInterestRateAndBorrowAmount(\r\n                borrowAmount,\r\n                totalAssetSupply(),\r\n                initialLoanDuration\r\n            );\r\n\r\n            if (borrowAmount > _underlyingBalance()) {\r\n                borrowAmount = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /* Internal functions */\r\n\r\n    function _mintToken(\r\n        address receiver,\r\n        uint256 depositAmount)\r\n        internal\r\n        settlesInterest\r\n        returns (uint256 mintAmount)\r\n    {\r\n        require (depositAmount != 0, \"17\");\r\n\r\n        uint256 currentPrice = _tokenPrice(_totalAssetSupply(0));\r\n        mintAmount = depositAmount\r\n            .mul(WEI_PRECISION)\r\n            .div(currentPrice);\r\n\r\n        if (msg.value == 0) {\r\n            _safeTransferFrom(loanTokenAddress, msg.sender, address(this), depositAmount, \"18\");\r\n        } else {\r\n            require(msg.value == depositAmount, \"18\");\r\n            IWeth(wethToken).deposit.value(depositAmount)();\r\n        }\r\n\r\n        _updateCheckpoints(\r\n            receiver,\r\n            balances[receiver],\r\n            _mint(receiver, mintAmount, depositAmount, currentPrice), // newBalance\r\n            currentPrice\r\n        );\r\n    }\r\n\r\n    function _burnToken(\r\n        uint256 burnAmount)\r\n        internal\r\n        settlesInterest\r\n        returns (uint256 loanAmountPaid)\r\n    {\r\n        require(burnAmount != 0, \"19\");\r\n\r\n        if (burnAmount > balanceOf(msg.sender)) {\r\n            require(burnAmount == uint256(-1), \"32\");\r\n            burnAmount = balanceOf(msg.sender);\r\n        }\r\n\r\n        uint256 currentPrice = _tokenPrice(_totalAssetSupply(0));\r\n\r\n        uint256 loanAmountOwed = burnAmount\r\n            .mul(currentPrice)\r\n            .div(WEI_PRECISION);\r\n        uint256 loanAmountAvailableInContract = _underlyingBalance();\r\n\r\n        loanAmountPaid = loanAmountOwed;\r\n        require(loanAmountPaid <= loanAmountAvailableInContract, \"37\");\r\n\r\n        _updateCheckpoints(\r\n            msg.sender,\r\n            balances[msg.sender],\r\n            _burn(msg.sender, burnAmount, loanAmountPaid, currentPrice), // newBalance\r\n            currentPrice\r\n        );\r\n    }\r\n\r\n    function _borrow(\r\n        bytes32 loanId,                 // 0 if new loan\r\n        uint256 withdrawAmount,\r\n        uint256 initialLoanDuration,    // duration in seconds\r\n        uint256 collateralTokenSent,    // if 0, loanId must be provided; any ETH sent must equal this value\r\n        address collateralTokenAddress, // if address(0), this means ETH and ETH must be sent with the call or loanId must be provided\r\n        address borrower,\r\n        address receiver,\r\n        bytes memory /*loanDataBytes*/) // arbitrary order data (for future use)\r\n        internal\r\n        pausable(msg.sig)\r\n        settlesInterest\r\n        returns (uint256, uint256) // returns new principal and new collateral added to loan\r\n    {\r\n        require(withdrawAmount != 0, \"6\");\r\n\r\n        require(msg.value == 0 || msg.value == collateralTokenSent, \"7\");\r\n        require(collateralTokenSent != 0 || loanId != 0, \"8\");\r\n        require(collateralTokenAddress != address(0) || msg.value != 0 || loanId != 0, \"9\");\r\n\r\n        // ensures authorized use of existing loan\r\n        require(loanId == 0 || msg.sender == borrower, \"13\");\r\n\r\n        if (collateralTokenAddress == address(0)) {\r\n            collateralTokenAddress = wethToken;\r\n        }\r\n        require(collateralTokenAddress != loanTokenAddress, \"10\");\r\n\r\n        address[4] memory sentAddresses;\r\n        uint256[5] memory sentAmounts;\r\n\r\n        sentAddresses[0] = address(this); // lender\r\n        sentAddresses[1] = borrower;\r\n        sentAddresses[2] = receiver;\r\n        //sentAddresses[3] = address(0); // manager\r\n\r\n        //sentAmounts[0] = 0; // interestRate (found later)\r\n        //sentAmounts[1] = 0; // borrowAmount (found later)\r\n        //sentAmounts[2] = 0; // interestInitialAmount (found later)\r\n        //sentAmounts[3] = 0; // loanTokenSent\r\n        sentAmounts[4] = collateralTokenSent;\r\n\r\n        // interestRate, interestInitialAmount, borrowAmount (newBorrowAmount)\r\n        (sentAmounts[0], sentAmounts[2], sentAmounts[1]) = _getInterestRateAndBorrowAmount(\r\n            withdrawAmount,\r\n            _totalAssetSupply(0), // interest is settled above\r\n            initialLoanDuration\r\n        );\r\n\r\n        return _borrowOrTrade(\r\n            loanId,\r\n            withdrawAmount,\r\n            0, // leverageAmount (calculated later)\r\n            collateralTokenAddress,\r\n            sentAddresses,\r\n            sentAmounts,\r\n            \"\" // loanDataBytes\r\n        );\r\n    }\r\n\r\n    function _marginTrade(\r\n        bytes32 loanId,                 // 0 if new loan\r\n        uint256 leverageAmount,\r\n        uint256 loanTokenSent,\r\n        uint256 collateralTokenSent,\r\n        address collateralTokenAddress,\r\n        address trader,\r\n        bytes memory loanDataBytes)\r\n        internal\r\n        pausable(msg.sig)\r\n        settlesInterest\r\n        returns (uint256, uint256) // returns new principal and new collateral added to trade\r\n    {\r\n        // ensures authorized use of existing loan\r\n        require(loanId == 0 || msg.sender == trader, \"13\");\r\n\r\n        if (collateralTokenAddress == address(0)) {\r\n            collateralTokenAddress = wethToken;\r\n        }\r\n        require(collateralTokenAddress != loanTokenAddress, \"11\");\r\n\r\n        uint256 totalDeposit = _totalDeposit(\r\n            collateralTokenAddress,\r\n            collateralTokenSent,\r\n            loanTokenSent\r\n        );\r\n        require(totalDeposit != 0, \"12\");\r\n\r\n        address[4] memory sentAddresses;\r\n        uint256[5] memory sentAmounts;\r\n\r\n        sentAddresses[0] = address(this); // lender\r\n        sentAddresses[1] = trader;\r\n        sentAddresses[2] = trader;\r\n        //sentAddresses[3] = address(0); // manager\r\n\r\n        //sentAmounts[0] = 0; // interestRate (found later)\r\n        //sentAmounts[1] = 0; // borrowAmount (found later)\r\n        //sentAmounts[2] = 0; // interestInitialAmount (interest is calculated based on fixed-term loan)\r\n        sentAmounts[3] = loanTokenSent;\r\n        sentAmounts[4] = collateralTokenSent;\r\n\r\n        (sentAmounts[1], sentAmounts[0]) = _getMarginBorrowAmountAndRate( // borrowAmount, interestRate\r\n            leverageAmount,\r\n            totalDeposit\r\n        );\r\n\r\n        return _borrowOrTrade(\r\n            loanId,\r\n            0, // withdrawAmount\r\n            leverageAmount,\r\n            collateralTokenAddress,\r\n            sentAddresses,\r\n            sentAmounts,\r\n            loanDataBytes\r\n        );\r\n    }\r\n\r\n    function _settleInterest()\r\n        internal\r\n    {\r\n        uint88 ts = uint88(block.timestamp);\r\n        if (lastSettleTime_ != ts) {\r\n            ProtocolLike(bZxContract).withdrawAccruedInterest(\r\n                loanTokenAddress\r\n            );\r\n\r\n            lastSettleTime_ = ts;\r\n        }\r\n    }\r\n\r\n    function _totalDeposit(\r\n        address collateralTokenAddress,\r\n        uint256 collateralTokenSent,\r\n        uint256 loanTokenSent)\r\n        internal\r\n        view\r\n        returns (uint256 totalDeposit)\r\n    {\r\n        totalDeposit = loanTokenSent;\r\n        if (collateralTokenSent != 0) {\r\n            (uint256 sourceToDestRate, uint256 sourceToDestPrecision) = FeedsLike(ProtocolLike(bZxContract).priceFeeds()).queryRate(\r\n                collateralTokenAddress,\r\n                loanTokenAddress\r\n            );\r\n            if (sourceToDestRate != 0) {\r\n                totalDeposit = collateralTokenSent\r\n                    .mul(sourceToDestRate)\r\n                    .div(sourceToDestPrecision)\r\n                    .add(totalDeposit);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _getInterestRateAndBorrowAmount(\r\n        uint256 borrowAmount,\r\n        uint256 assetSupply,\r\n        uint256 initialLoanDuration) // duration in seconds\r\n        internal\r\n        view\r\n        returns (uint256 interestRate, uint256 interestInitialAmount, uint256 newBorrowAmount)\r\n    {\r\n        interestRate = _nextBorrowInterestRate2(\r\n            borrowAmount,\r\n            assetSupply\r\n        );\r\n\r\n        // newBorrowAmount = borrowAmount * 10^18 / (10^18 - (interestRate * initialLoanDuration * 10^18 / (31536000 * 10^20)))\r\n        newBorrowAmount = borrowAmount\r\n            .mul(WEI_PRECISION)\r\n            .div(\r\n                SafeMath.sub(WEI_PRECISION,\r\n                    interestRate\r\n                        .mul(initialLoanDuration)\r\n                        .mul(WEI_PRECISION)\r\n                        .div(31536000 * WEI_PERCENT_PRECISION) // 365 * 86400 * WEI_PERCENT_PRECISION\r\n                )\r\n            );\r\n\r\n        interestInitialAmount = newBorrowAmount\r\n            .sub(borrowAmount);\r\n    }\r\n\r\n    // returns newPrincipal\r\n    function _borrowOrTrade(\r\n        bytes32 loanId,\r\n        uint256 withdrawAmount,\r\n        uint256 leverageAmount,\r\n        address collateralTokenAddress,\r\n        address[4] memory sentAddresses,\r\n        uint256[5] memory sentAmounts,\r\n        bytes memory loanDataBytes)\r\n        internal\r\n        returns (uint256, uint256)\r\n    {\r\n        require (sentAmounts[1] <= _underlyingBalance() && // newPrincipal\r\n            sentAddresses[1] != address(0), // borrower\r\n            \"24\"\r\n        );\r\n\r\n\t    if (sentAddresses[2] == address(0)) {\r\n            sentAddresses[2] = sentAddresses[1]; // receiver = borrower\r\n        }\r\n\r\n        // handle transfers prior to adding newPrincipal to loanTokenSent\r\n        uint256 msgValue = _verifyTransfers(\r\n            collateralTokenAddress,\r\n            sentAddresses,\r\n            sentAmounts,\r\n            withdrawAmount\r\n        );\r\n\r\n        // adding the loan token portion from the lender to loanTokenSent\r\n        sentAmounts[3] = sentAmounts[3]\r\n            .add(sentAmounts[1]); // newPrincipal\r\n\r\n        if (withdrawAmount != 0) {\r\n            // withdrawAmount already sent to the borrower, so we aren't sending it to the protocol\r\n            sentAmounts[3] = sentAmounts[3]\r\n                .sub(withdrawAmount);\r\n        }\r\n\r\n        bool isTorqueLoan = withdrawAmount != 0 ?\r\n            true :\r\n            false;\r\n\r\n        bytes32 loanParamsId = loanParamsIds[uint256(keccak256(abi.encodePacked(\r\n            collateralTokenAddress,\r\n            isTorqueLoan\r\n        )))];\r\n\r\n        // converting to initialMargin\r\n        if (leverageAmount != 0) {\r\n            leverageAmount = SafeMath.div(WEI_PRECISION * WEI_PERCENT_PRECISION, leverageAmount);\r\n        }\r\n\r\n        (sentAmounts[1], sentAmounts[4]) = ProtocolLike(bZxContract).borrowOrTradeFromPool.value(msgValue)( // newPrincipal, newCollateral\r\n            loanParamsId,\r\n            loanId,\r\n            isTorqueLoan,\r\n            leverageAmount, // initialMargin\r\n            sentAddresses,\r\n            sentAmounts,\r\n            loanDataBytes\r\n        );\r\n        require (sentAmounts[1] != 0, \"25\");\r\n\r\n        return (sentAmounts[1], sentAmounts[4]); // newPrincipal, newCollateral\r\n    }\r\n\r\n    // sentAddresses[0]: lender\r\n    // sentAddresses[1]: borrower\r\n    // sentAddresses[2]: receiver\r\n    // sentAddresses[3]: manager\r\n    // sentAmounts[0]: interestRate\r\n    // sentAmounts[1]: newPrincipal\r\n    // sentAmounts[2]: interestInitialAmount\r\n    // sentAmounts[3]: loanTokenSent\r\n    // sentAmounts[4]: collateralTokenSent\r\n    function _verifyTransfers(\r\n        address collateralTokenAddress,\r\n        address[4] memory sentAddresses,\r\n        uint256[5] memory sentAmounts,\r\n        uint256 withdrawalAmount)\r\n        internal\r\n        returns (uint256 msgValue)\r\n    {\r\n        address _wethToken = wethToken;\r\n        address _loanTokenAddress = loanTokenAddress;\r\n        address receiver = sentAddresses[2];\r\n        uint256 newPrincipal = sentAmounts[1];\r\n        uint256 loanTokenSent = sentAmounts[3];\r\n        uint256 collateralTokenSent = sentAmounts[4];\r\n\r\n        require(_loanTokenAddress != collateralTokenAddress, \"26\");\r\n\r\n        msgValue = msg.value;\r\n\r\n        if (withdrawalAmount != 0) { // withdrawOnOpen == true\r\n            _safeTransfer(_loanTokenAddress, receiver, withdrawalAmount, \"27\");\r\n            if (newPrincipal > withdrawalAmount) {\r\n                _safeTransfer(_loanTokenAddress, bZxContract, newPrincipal - withdrawalAmount, \"27\");\r\n            }\r\n        } else {\r\n            _safeTransfer(_loanTokenAddress, bZxContract, newPrincipal, \"27\");\r\n        }\r\n\r\n        if (collateralTokenSent != 0) {\r\n            if (collateralTokenAddress == _wethToken && msgValue != 0 && msgValue >= collateralTokenSent) {\r\n                IWeth(_wethToken).deposit.value(collateralTokenSent)();\r\n                _safeTransfer(collateralTokenAddress, bZxContract, collateralTokenSent, \"28\");\r\n                msgValue -= collateralTokenSent;\r\n            } else {\r\n                _safeTransferFrom(collateralTokenAddress, msg.sender, bZxContract, collateralTokenSent, \"28\");\r\n            }\r\n        }\r\n\r\n        if (loanTokenSent != 0) {\r\n            _safeTransferFrom(_loanTokenAddress, msg.sender, bZxContract, loanTokenSent, \"29\");\r\n        }\r\n    }\r\n\r\n    function _safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 amount,\r\n        string memory errorMsg)\r\n        internal\r\n    {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(IERC20(token).transfer.selector, to, amount),\r\n            errorMsg\r\n        );\r\n    }\r\n\r\n    function _safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        string memory errorMsg)\r\n        internal\r\n    {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(IERC20(token).transferFrom.selector, from, to, amount),\r\n            errorMsg\r\n        );\r\n    }\r\n\r\n    function _callOptionalReturn(\r\n        address token,\r\n        bytes memory data,\r\n        string memory errorMsg)\r\n        internal\r\n    {\r\n        (bool success, bytes memory returndata) = token.call(data);\r\n        require(success, errorMsg);\r\n\r\n        if (returndata.length != 0) {\r\n            require(abi.decode(returndata, (bool)), errorMsg);\r\n        }\r\n    }\r\n\r\n    function _underlyingBalance()\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return IERC20(loanTokenAddress).balanceOf(address(this));\r\n    }\r\n\r\n    /* Internal View functions */\r\n\r\n    function _tokenPrice(\r\n        uint256 assetSupply)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 totalTokenSupply = totalSupply_;\r\n\r\n        return totalTokenSupply != 0 ?\r\n            assetSupply\r\n                .mul(WEI_PRECISION)\r\n                .div(totalTokenSupply) : initialPrice;\r\n    }\r\n\r\n    function _avgBorrowInterestRate(\r\n        uint256 assetBorrow)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (assetBorrow != 0) {\r\n            (uint256 interestOwedPerDay,) = _getAllInterest();\r\n            return interestOwedPerDay\r\n                .mul(365 * WEI_PERCENT_PRECISION)\r\n                .div(assetBorrow);\r\n        }\r\n    }\r\n\r\n    // next supply interest adjustment\r\n    function _supplyInterestRate(\r\n        uint256 assetBorrow,\r\n        uint256 assetSupply)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (assetBorrow != 0 && assetSupply >= assetBorrow) {\r\n            return _avgBorrowInterestRate(assetBorrow)\r\n                .mul(_utilizationRate(assetBorrow, assetSupply))\r\n                .mul(SafeMath.sub(WEI_PERCENT_PRECISION, ProtocolLike(bZxContract).lendingFeePercent()))\r\n                .div(WEI_PERCENT_PRECISION * WEI_PERCENT_PRECISION);\r\n        }\r\n    }\r\n\r\n    function _nextBorrowInterestRate(\r\n        uint256 borrowAmount)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 interestUnPaid;\r\n        if (borrowAmount != 0) {\r\n            if (lastSettleTime_ != uint88(block.timestamp)) {\r\n                (,interestUnPaid) = _getAllInterest();\r\n            }\r\n\r\n            uint256 balance = _underlyingBalance()\r\n                .add(interestUnPaid);\r\n            if (borrowAmount > balance) {\r\n                borrowAmount = balance;\r\n            }\r\n        }\r\n\r\n        return _nextBorrowInterestRate2(\r\n            borrowAmount,\r\n            _totalAssetSupply(interestUnPaid)\r\n        );\r\n    }\r\n\r\n    function _nextBorrowInterestRate2(\r\n        uint256 newBorrowAmount,\r\n        uint256 assetSupply)\r\n        internal\r\n        view\r\n        returns (uint256 nextRate)\r\n    {\r\n        uint256 utilRate = _utilizationRate(\r\n            totalAssetBorrow().add(newBorrowAmount),\r\n            assetSupply\r\n        );\r\n\r\n        uint256 thisMinRate;\r\n        uint256 thisMaxRate;\r\n        uint256 thisBaseRate = baseRate;\r\n        uint256 thisRateMultiplier = rateMultiplier;\r\n        uint256 thisTargetLevel = targetLevel;\r\n        uint256 thisKinkLevel = kinkLevel;\r\n        uint256 thisMaxScaleRate = maxScaleRate;\r\n\r\n        if (utilRate < thisTargetLevel) {\r\n            // target targetLevel utilization when utilization is under targetLevel\r\n            utilRate = thisTargetLevel;\r\n        }\r\n\r\n        if (utilRate > thisKinkLevel) {\r\n            // scale rate proportionally up to 100%\r\n            uint256 thisMaxRange = WEI_PERCENT_PRECISION - thisKinkLevel; // will not overflow\r\n\r\n            utilRate -= thisKinkLevel;\r\n            if (utilRate > thisMaxRange)\r\n                utilRate = thisMaxRange;\r\n\r\n            thisMaxRate = thisRateMultiplier\r\n                .add(thisBaseRate)\r\n                .mul(thisKinkLevel)\r\n                .div(WEI_PERCENT_PRECISION);\r\n\r\n            nextRate = utilRate\r\n                .mul(SafeMath.sub(thisMaxScaleRate, thisMaxRate))\r\n                .div(thisMaxRange)\r\n                .add(thisMaxRate);\r\n        } else {\r\n            nextRate = utilRate\r\n                .mul(thisRateMultiplier)\r\n                .div(WEI_PERCENT_PRECISION)\r\n                .add(thisBaseRate);\r\n\r\n            thisMinRate = thisBaseRate;\r\n            thisMaxRate = thisRateMultiplier\r\n                .add(thisBaseRate);\r\n\r\n            if (nextRate < thisMinRate)\r\n                nextRate = thisMinRate;\r\n            else if (nextRate > thisMaxRate)\r\n                nextRate = thisMaxRate;\r\n        }\r\n    }\r\n\r\n    function _getAllInterest()\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 interestOwedPerDay,\r\n            uint256 interestUnPaid)\r\n    {\r\n        // interestPaid, interestPaidDate, interestOwedPerDay, interestUnPaid, interestFeePercent, principalTotal\r\n        uint256 interestFeePercent;\r\n        (,,interestOwedPerDay,interestUnPaid,interestFeePercent,) = ProtocolLike(bZxContract).getLenderInterestData(\r\n            address(this),\r\n            loanTokenAddress\r\n        );\r\n\r\n        interestUnPaid = interestUnPaid\r\n            .mul(SafeMath.sub(WEI_PERCENT_PRECISION, interestFeePercent))\r\n            .div(WEI_PERCENT_PRECISION);\r\n    }\r\n\r\n    function _getMarginBorrowAmountAndRate(\r\n        uint256 leverageAmount,\r\n        uint256 depositAmount)\r\n        internal\r\n        view\r\n        returns (uint256 borrowAmount, uint256 interestRate)\r\n    {\r\n        uint256 initialMargin = SafeMath.div(WEI_PRECISION * WEI_PERCENT_PRECISION, leverageAmount);\r\n\r\n        interestRate = _nextBorrowInterestRate2(\r\n            depositAmount\r\n                .mul(WEI_PERCENT_PRECISION)\r\n                .div(initialMargin),\r\n            _totalAssetSupply(0)\r\n        );\r\n\r\n        // assumes that loan, collateral, and interest token are the same\r\n        borrowAmount = depositAmount\r\n            .mul(WEI_PERCENT_PRECISION * WEI_PERCENT_PRECISION)\r\n            .div(_adjustValue(\r\n                interestRate,\r\n                2419200, // 28 day duration for margin trades\r\n                initialMargin))\r\n            .div(initialMargin);\r\n    }\r\n\r\n    function _totalAssetSupply(\r\n        uint256 interestUnPaid)\r\n        internal\r\n        view\r\n        returns (uint256) // assetSupply\r\n    {\r\n        if (totalSupply_ != 0) {\r\n            uint256 assetsBalance = _flTotalAssetSupply; // temporary locked totalAssetSupply during a flash loan transaction\r\n            if (assetsBalance == 0) {\r\n                assetsBalance = _underlyingBalance()\r\n                    .add(totalAssetBorrow());\r\n            }\r\n\r\n            return assetsBalance\r\n                .add(interestUnPaid);\r\n        }\r\n    }\r\n\r\n    function _adjustValue(\r\n        uint256 interestRate,\r\n        uint256 maxDuration,\r\n        uint256 marginAmount)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return maxDuration != 0 ?\r\n            interestRate\r\n                .mul(WEI_PERCENT_PRECISION)\r\n                .mul(maxDuration)\r\n                .div(31536000) // 86400 * 365\r\n                .div(marginAmount)\r\n                .add(WEI_PERCENT_PRECISION) :\r\n            WEI_PERCENT_PRECISION;\r\n    }\r\n\r\n    function _utilizationRate(\r\n        uint256 assetBorrow,\r\n        uint256 assetSupply)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (assetBorrow != 0 && assetSupply != 0) {\r\n            // U = total_borrow / total_supply\r\n            return assetBorrow\r\n                .mul(WEI_PERCENT_PRECISION)\r\n                .div(assetSupply);\r\n        }\r\n    }\r\n\r\n\r\n    /* Owner-Only functions */\r\n\r\n    function updateSettings(\r\n        address settingsTarget,\r\n        bytes memory callData)\r\n        public\r\n    {\r\n        if (msg.sender != owner()) {\r\n            address _lowerAdmin;\r\n            address _lowerAdminContract;\r\n            assembly {\r\n                _lowerAdmin := sload(iToken_LowerAdminAddress)\r\n                _lowerAdminContract := sload(iToken_LowerAdminContract)\r\n            }\r\n            require(msg.sender == _lowerAdmin && settingsTarget == _lowerAdminContract);\r\n        }\r\n\r\n        address currentTarget = target_;\r\n        target_ = settingsTarget;\r\n\r\n        (bool result,) = address(this).call(callData);\r\n\r\n        uint256 size;\r\n        uint256 ptr;\r\n        assembly {\r\n            size := returndatasize\r\n            ptr := mload(0x40)\r\n            returndatacopy(ptr, 0, size)\r\n            if eq(result, 0) { revert(ptr, size) }\r\n        }\r\n\r\n        target_ = currentTarget;\r\n\r\n        assembly {\r\n            return(ptr, size)\r\n        }\r\n    }\r\n}\r\n\r\ncontract LoanTokenLogicWeth is LoanTokenLogicStandard {\r\n\r\n    constructor(\r\n        address _newOwner)\r\n        public\r\n        LoanTokenLogicStandard(_newOwner)\r\n    {}\r\n\r\n    function mintWithEther(\r\n        address receiver)\r\n        external\r\n        payable\r\n        nonReentrant\r\n        returns (uint256 mintAmount)\r\n    {\r\n        return _mintToken(\r\n            receiver,\r\n            msg.value\r\n        );\r\n    }\r\n\r\n    function burnToEther(\r\n        address receiver,\r\n        uint256 burnAmount)\r\n        external\r\n        nonReentrant\r\n        returns (uint256 loanAmountPaid)\r\n    {\r\n        loanAmountPaid = _burnToken(\r\n            burnAmount\r\n        );\r\n\r\n        if (loanAmountPaid != 0) {\r\n            IWethERC20(wethToken).withdraw(loanAmountPaid);\r\n            Address.sendValue(\r\n                receiver,\r\n                loanAmountPaid\r\n            );\r\n        }\r\n    }\r\n\r\n    /* Internal functions */\r\n\r\n    // sentAddresses[0]: lender\r\n    // sentAddresses[1]: borrower\r\n    // sentAddresses[2]: receiver\r\n    // sentAddresses[3]: manager\r\n    // sentAmounts[0]: interestRate\r\n    // sentAmounts[1]: newPrincipal\r\n    // sentAmounts[2]: interestInitialAmount\r\n    // sentAmounts[3]: loanTokenSent\r\n    // sentAmounts[4]: collateralTokenSent\r\n    function _verifyTransfers(\r\n        address collateralTokenAddress,\r\n        address[4] memory sentAddresses,\r\n        uint256[5] memory sentAmounts,\r\n        uint256 withdrawalAmount)\r\n        internal\r\n        returns (uint256 msgValue)\r\n    {\r\n        address _wethToken = wethToken;\r\n        address _loanTokenAddress = _wethToken;\r\n        address receiver = sentAddresses[2];\r\n        uint256 newPrincipal = sentAmounts[1];\r\n        uint256 loanTokenSent = sentAmounts[3];\r\n        uint256 collateralTokenSent = sentAmounts[4];\r\n\r\n        require(_loanTokenAddress != collateralTokenAddress, \"26\");\r\n\r\n        msgValue = msg.value;\r\n\r\n        if (withdrawalAmount != 0) { // withdrawOnOpen == true\r\n            IWethERC20(_wethToken).withdraw(withdrawalAmount);\r\n            Address.sendValue(\r\n                receiver,\r\n                withdrawalAmount\r\n            );\r\n            if (newPrincipal > withdrawalAmount) {\r\n                _safeTransfer(_loanTokenAddress, bZxContract, newPrincipal - withdrawalAmount, \"27\");\r\n            }\r\n        } else {\r\n            _safeTransfer(_loanTokenAddress, bZxContract, newPrincipal, \"27\");\r\n        }\r\n\r\n        if (collateralTokenSent != 0) {\r\n            _safeTransferFrom(collateralTokenAddress, msg.sender, bZxContract, collateralTokenSent, \"28\");\r\n        }\r\n\r\n        if (loanTokenSent != 0) {\r\n            if (msgValue != 0 && msgValue >= loanTokenSent) {\r\n                IWeth(_wethToken).deposit.value(loanTokenSent)();\r\n                _safeTransfer(_loanTokenAddress, bZxContract, loanTokenSent, \"29\");\r\n                msgValue -= loanTokenSent;\r\n            } else {\r\n                _safeTransferFrom(_loanTokenAddress, msg.sender, bZxContract, loanTokenSent, \"29\");\r\n            }\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"assetBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"avgBorrowInterestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bZxContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"loanId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialLoanDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralTokenSent\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collateralTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"borrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"borrowInterestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"loanId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialLoanDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralTokenSent\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collateralTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"gasTokenUser\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"borrowWithGasToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"burnAmount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"loanAmountPaid\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"burnAmount\",\"type\":\"uint256\"}],\"name\":\"burnToEther\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"loanAmountPaid\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"checkpointPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkpointSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"signature\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"flashBorrow\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gasToken\",\"outputs\":[{\"internalType\":\"contract ITokenHolderLike\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialLoanDuration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collateralTokenAddress\",\"type\":\"address\"}],\"name\":\"getBorrowAmountForDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialLoanDuration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collateralTokenAddress\",\"type\":\"address\"}],\"name\":\"getDepositAmountForBorrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"leverageAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanTokenSent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralTokenSent\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collateralTokenAddress\",\"type\":\"address\"}],\"name\":\"getEstimatedMarginDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"leverageAmount\",\"type\":\"uint256\"}],\"name\":\"getMaxEscrowAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kinkLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"loanParamsIds\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"loanTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lowUtilBaseRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lowUtilRateMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"loanId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"leverageAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanTokenSent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralTokenSent\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collateralTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"loanDataBytes\",\"type\":\"bytes\"}],\"name\":\"marginTrade\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"loanId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"leverageAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanTokenSent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralTokenSent\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collateralTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"gasTokenUser\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"loanDataBytes\",\"type\":\"bytes\"}],\"name\":\"marginTradeWithGasToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxScaleRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"mintWithEther\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"name\":\"nextBorrowInterestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"supplyAmount\",\"type\":\"uint256\"}],\"name\":\"nextSupplyInterestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"profitOf\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rateMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supplyInterestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"targetLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenHolder\",\"outputs\":[{\"internalType\":\"contract ITokenHolderLike\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAssetBorrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAssetSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetSupply\",\"type\":\"uint256\"}],\"name\":\"totalSupplyInterestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"settingsTarget\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"name\":\"updateSettings\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wethToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "LoanTokenLogicWeth", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000b7f72028d9b502dc871c444363a7ac5a52546608", "EVMVersion": "Default", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://0b0ac6d99a2ca99b0037ccf24e11ba659b4164d89f5f625c7779269fe66e8539"}