{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/EIP20Interface.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n/**\\n * @title ERC 20 Token Standard Interface\\n *  https://eips.ethereum.org/EIPS/eip-20\\n */\\ninterface EIP20Interface {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n      * @notice Get the total number of tokens in circulation\\n      * @return The supply of tokens\\n      */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the balance of the specified address\\n     * @param owner The address from which the balance will be retrieved\\n     * @return The balance\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      * @return Whether or not the transfer succeeded\\n      */\\n    function transfer(address dst, uint256 amount) external returns (bool success);\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `src` to `dst`\\n      * @param src The address of the source account\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      * @return Whether or not the transfer succeeded\\n      */\\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool success);\\n\\n    /**\\n      * @notice Approve `spender` to transfer up to `amount` from `src`\\n      * @dev This will overwrite the approval amount for `spender`\\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n      * @param spender The address of the account which may transfer tokens\\n      * @param amount The number of tokens that are approved (-1 means infinite)\\n      * @return Whether or not the approval succeeded\\n      */\\n    function approve(address spender, uint256 amount) external returns (bool success);\\n\\n    /**\\n      * @notice Get the current allowance from `owner` for `spender`\\n      * @param owner The address of the account which owns the tokens to be spent\\n      * @param spender The address of the account which may transfer tokens\\n      * @return The number of tokens allowed to be spent (-1 means infinite)\\n      */\\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n}\\n\",\r\n      \"keccak256\": \"0xfd8ed2eac6d0b4d9ee6b32628ba68bae17544b66f190a5f7ce0c6ad024579dc8\"\r\n    },\r\n    \"contracts/Reservoir.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n/**\\n * @title Reservoir Contract\\n * @notice Distributes a token to a different contract at a fixed rate.\\n * @dev This contract must be poked via the `drip()` function every so often.\\n * @author Compound\\n */\\ncontract Reservoir {\\n\\n  /// @notice The block number when the Reservoir started (immutable)\\n  uint public dripStart;\\n\\n  /// @notice Tokens per block that to drip to target (immutable)\\n  uint public dripRate;\\n\\n  /// @notice Reference to token to drip (immutable)\\n  EIP20Interface public token;\\n\\n  /// @notice Target to receive dripped tokens (immutable)\\n  address public target;\\n\\n  /// @notice Amount that has already been dripped\\n  uint public dripped;\\n\\n  /**\\n    * @notice Constructs a Reservoir\\n    * @param dripRate_ Numer of tokens per block to drip\\n    * @param token_ The token to drip\\n    * @param target_ The recipient of dripped tokens\\n    */\\n  constructor(uint dripRate_, EIP20Interface token_, address target_) public {\\n    dripStart = block.number;\\n    dripRate = dripRate_;\\n    token = token_;\\n    target = target_;\\n    dripped = 0;\\n  }\\n\\n  /**\\n    * @notice Drips the maximum amount of tokens to match the drip rate since inception\\n    * @dev Note: this will only drip up to the amount of tokens available.\\n    * @return The amount of tokens dripped in this call\\n    */\\n  function drip() public returns (uint) {\\n    // First, read storage into memory\\n    EIP20Interface token_ = token;\\n    uint reservoirBalance_ = token_.balanceOf(address(this)); // TODO: Verify this is a static call\\n    uint dripRate_ = dripRate;\\n    uint dripStart_ = dripStart;\\n    uint dripped_ = dripped;\\n    address target_ = target;\\n    uint blockNumber_ = block.number;\\n\\n    // Next, calculate intermediate values\\n    uint dripTotal_ = mul(dripRate_, blockNumber_ - dripStart_, \\\"dripTotal overflow\\\");\\n    uint deltaDrip_ = sub(dripTotal_, dripped_, \\\"deltaDrip underflow\\\");\\n    uint toDrip_ = min(reservoirBalance_, deltaDrip_);\\n    uint drippedNext_ = add(dripped_, toDrip_, \\\"tautological\\\");\\n\\n    // Finally, write new `dripped` value and transfer tokens to target\\n    dripped = drippedNext_;\\n    token_.transfer(target_, toDrip_);\\n\\n    return toDrip_;\\n  }\\n\\n  /* Internal helper functions for safe math */\\n\\n  function add(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\\n    uint c = a + b;\\n    require(c >= a, errorMessage);\\n    return c;\\n  }\\n\\n  function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\\n    require(b <= a, errorMessage);\\n    uint c = a - b;\\n    return c;\\n  }\\n\\n  function mul(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n    uint c = a * b;\\n    require(c / a == b, errorMessage);\\n    return c;\\n  }\\n\\n  function min(uint a, uint b) internal pure returns (uint) {\\n    if (a <= b) {\\n      return a;\\n    } else {\\n      return b;\\n    }\\n  }\\n}\\n\\nimport \\\"./EIP20Interface.sol\\\";\\n\",\r\n      \"keccak256\": \"0x58202c0546a41db3d50b4a5936e196ef1b50642f3d23a8f3a039d3133800bb35\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dripRate_\",\"type\":\"uint256\"},{\"internalType\":\"contract EIP20Interface\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":false,\"inputs\":[],\"name\":\"drip\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dripRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dripStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dripped\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"target\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract EIP20Interface\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Reservoir", "CompilerVersion": "v0.5.16+commit.9c3226ce", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000006f05b59d3b20000000000000000000000000000c00e94cb662c3520282e6f5717214004a7f268880000000000000000000000003d9819210a31b4961b30ef54be2aed79b9c9cd3b", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}