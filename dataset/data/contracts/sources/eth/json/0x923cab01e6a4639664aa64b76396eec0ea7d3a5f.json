{"SourceCode": "// File: contracts/token/interfaces/IERC20Token.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/*\r\n    ERC20 Standard Token interface\r\n*/\r\ncontract IERC20Token {\r\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\r\n    function name() public view returns (string) {this;}\r\n    function symbol() public view returns (string) {this;}\r\n    function decimals() public view returns (uint8) {this;}\r\n    function totalSupply() public view returns (uint256) {this;}\r\n    function balanceOf(address _owner) public view returns (uint256) {_owner; this;}\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {_owner; _spender; this;}\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n}\r\n\r\n// File: contracts/IBancorNetwork.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n/*\r\n    Bancor Network interface\r\n*/\r\ncontract IBancorNetwork {\r\n    function convert2(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    ) public payable returns (uint256);\r\n\r\n    function claimAndConvert2(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    ) public returns (uint256);\r\n\r\n    function convertFor2(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    ) public payable returns (uint256);\r\n\r\n    function claimAndConvertFor2(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    ) public returns (uint256);\r\n\r\n    // deprecated, backward compatibility\r\n    function convert(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn\r\n    ) public payable returns (uint256);\r\n\r\n    // deprecated, backward compatibility\r\n    function claimAndConvert(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn\r\n    ) public returns (uint256);\r\n\r\n    // deprecated, backward compatibility\r\n    function convertFor(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for\r\n    ) public payable returns (uint256);\r\n\r\n    // deprecated, backward compatibility\r\n    function claimAndConvertFor(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for\r\n    ) public returns (uint256);\r\n}\r\n\r\n// File: contracts/IConversionPathFinder.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n/*\r\n    Conversion Path Finder interface\r\n*/\r\ncontract IConversionPathFinder {\r\n    function findPath(address _sourceToken, address _targetToken) public view returns (address[] memory);\r\n}\r\n\r\n// File: contracts/utility/interfaces/IOwned.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/*\r\n    Owned contract interface\r\n*/\r\ncontract IOwned {\r\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\r\n    function owner() public view returns (address) {this;}\r\n\r\n    function transferOwnership(address _newOwner) public;\r\n    function acceptOwnership() public;\r\n}\r\n\r\n// File: contracts/utility/interfaces/ITokenHolder.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n/*\r\n    Token Holder interface\r\n*/\r\ncontract ITokenHolder is IOwned {\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;\r\n}\r\n\r\n// File: contracts/converter/interfaces/IConverterAnchor.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n/*\r\n    Converter Anchor interface\r\n*/\r\ncontract IConverterAnchor is IOwned, ITokenHolder {\r\n}\r\n\r\n// File: contracts/utility/interfaces/IWhitelist.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/*\r\n    Whitelist interface\r\n*/\r\ncontract IWhitelist {\r\n    function isWhitelisted(address _address) public view returns (bool);\r\n}\r\n\r\n// File: contracts/converter/interfaces/IConverter.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n    Converter interface\r\n*/\r\ncontract IConverter is IOwned {\r\n    function converterType() public pure returns (uint16);\r\n    function anchor() public view returns (IConverterAnchor) {this;}\r\n    function isActive() public view returns (bool);\r\n\r\n    function rateAndFee(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount) public view returns (uint256, uint256);\r\n    function convert(IERC20Token _sourceToken,\r\n                     IERC20Token _targetToken,\r\n                     uint256 _amount,\r\n                     address _trader,\r\n                     address _beneficiary) public payable returns (uint256);\r\n\r\n    function conversionWhitelist() public view returns (IWhitelist) {this;}\r\n    function conversionFee() public view returns (uint32) {this;}\r\n    function maxConversionFee() public view returns (uint32) {this;}\r\n    function reserveBalance(IERC20Token _reserveToken) public view returns (uint256);\r\n    function() external payable;\r\n\r\n    function transferAnchorOwnership(address _newOwner) public;\r\n    function acceptAnchorOwnership() public;\r\n    function setConversionFee(uint32 _conversionFee) public;\r\n    function setConversionWhitelist(IWhitelist _whitelist) public;\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;\r\n    function withdrawETH(address _to) public;\r\n    function addReserve(IERC20Token _token, uint32 _ratio) public;\r\n\r\n    // deprecated, backward compatibility\r\n    function token() public view returns (IConverterAnchor);\r\n    function transferTokenOwnership(address _newOwner) public;\r\n    function acceptTokenOwnership() public;\r\n    function connectors(address _address) public view returns (uint256, uint32, bool, bool, bool);\r\n    function getConnectorBalance(IERC20Token _connectorToken) public view returns (uint256);\r\n    function connectorTokens(uint256 _index) public view returns (IERC20Token);\r\n    function connectorTokenCount() public view returns (uint16);\r\n}\r\n\r\n// File: contracts/converter/interfaces/IBancorFormula.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/*\r\n    Bancor Formula interface\r\n*/\r\ncontract IBancorFormula {\r\n    function purchaseRate(uint256 _supply,\r\n                          uint256 _reserveBalance,\r\n                          uint32 _reserveWeight,\r\n                          uint256 _amount)\r\n                          public view returns (uint256);\r\n\r\n    function saleRate(uint256 _supply,\r\n                      uint256 _reserveBalance,\r\n                      uint32 _reserveWeight,\r\n                      uint256 _amount)\r\n                      public view returns (uint256);\r\n\r\n    function crossReserveRate(uint256 _sourceReserveBalance,\r\n                              uint32 _sourceReserveWeight,\r\n                              uint256 _targetReserveBalance,\r\n                              uint32 _targetReserveWeight,\r\n                              uint256 _amount)\r\n                              public view returns (uint256);\r\n\r\n    function fundCost(uint256 _supply,\r\n                      uint256 _reserveBalance,\r\n                      uint32 _reserveRatio,\r\n                      uint256 _amount)\r\n                      public view returns (uint256);\r\n\r\n    function liquidateRate(uint256 _supply,\r\n                           uint256 _reserveBalance,\r\n                           uint32 _reserveRatio,\r\n                           uint256 _amount)\r\n                           public view returns (uint256);\r\n}\r\n\r\n// File: contracts/utility/Owned.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n/**\r\n  * @dev Provides support and utilities for contract ownership\r\n*/\r\ncontract Owned is IOwned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    /**\r\n      * @dev triggered when the owner is updated\r\n      *\r\n      * @param _prevOwner previous owner\r\n      * @param _newOwner  new owner\r\n    */\r\n    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\r\n\r\n    /**\r\n      * @dev initializes a new Owned instance\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier ownerOnly {\r\n        _ownerOnly();\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _ownerOnly() internal view {\r\n        require(msg.sender == owner, \"ERR_ACCESS_DENIED\");\r\n    }\r\n\r\n    /**\r\n      * @dev allows transferring the contract ownership\r\n      * the new owner still needs to accept the transfer\r\n      * can only be called by the contract owner\r\n      *\r\n      * @param _newOwner    new contract owner\r\n    */\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner, \"ERR_SAME_OWNER\");\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n      * @dev used by a new owner to accept an ownership transfer\r\n    */\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner, \"ERR_ACCESS_DENIED\");\r\n        emit OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n// File: contracts/utility/Utils.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/**\r\n  * @dev Utilities & Common Modifiers\r\n*/\r\ncontract Utils {\r\n    // verifies that a value is greater than zero\r\n    modifier greaterThanZero(uint256 _value) {\r\n        _greaterThanZero(_value);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _greaterThanZero(uint256 _value) internal pure {\r\n        require(_value > 0, \"ERR_ZERO_VALUE\");\r\n    }\r\n\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        _validAddress(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validAddress(address _address) internal pure {\r\n        require(_address != address(0), \"ERR_INVALID_ADDRESS\");\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThis(address _address) {\r\n        _notThis(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _notThis(address _address) internal view {\r\n        require(_address != address(this), \"ERR_ADDRESS_IS_SELF\");\r\n    }\r\n}\r\n\r\n// File: contracts/utility/interfaces/IContractRegistry.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/*\r\n    Contract Registry interface\r\n*/\r\ncontract IContractRegistry {\r\n    function addressOf(bytes32 _contractName) public view returns (address);\r\n\r\n    // deprecated, backward compatibility\r\n    function getAddress(bytes32 _contractName) public view returns (address);\r\n}\r\n\r\n// File: contracts/utility/ContractRegistryClient.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n\r\n/**\r\n  * @dev Base contract for ContractRegistry clients\r\n*/\r\ncontract ContractRegistryClient is Owned, Utils {\r\n    bytes32 internal constant CONTRACT_REGISTRY = \"ContractRegistry\";\r\n    bytes32 internal constant BANCOR_NETWORK = \"BancorNetwork\";\r\n    bytes32 internal constant BANCOR_FORMULA = \"BancorFormula\";\r\n    bytes32 internal constant CONVERTER_FACTORY = \"ConverterFactory\";\r\n    bytes32 internal constant CONVERSION_PATH_FINDER = \"ConversionPathFinder\";\r\n    bytes32 internal constant CONVERTER_UPGRADER = \"BancorConverterUpgrader\";\r\n    bytes32 internal constant CONVERTER_REGISTRY = \"BancorConverterRegistry\";\r\n    bytes32 internal constant CONVERTER_REGISTRY_DATA = \"BancorConverterRegistryData\";\r\n    bytes32 internal constant BNT_TOKEN = \"BNTToken\";\r\n    bytes32 internal constant BANCOR_X = \"BancorX\";\r\n    bytes32 internal constant BANCOR_X_UPGRADER = \"BancorXUpgrader\";\r\n\r\n    IContractRegistry public registry;      // address of the current contract-registry\r\n    IContractRegistry public prevRegistry;  // address of the previous contract-registry\r\n    bool public onlyOwnerCanUpdateRegistry; // only an owner can update the contract-registry\r\n\r\n    /**\r\n      * @dev verifies that the caller is mapped to the given contract name\r\n      *\r\n      * @param _contractName    contract name\r\n    */\r\n    modifier only(bytes32 _contractName) {\r\n        _only(_contractName);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _only(bytes32 _contractName) internal view {\r\n        require(msg.sender == addressOf(_contractName), \"ERR_ACCESS_DENIED\");\r\n    }\r\n\r\n    /**\r\n      * @dev initializes a new ContractRegistryClient instance\r\n      *\r\n      * @param  _registry   address of a contract-registry contract\r\n    */\r\n    constructor(IContractRegistry _registry) internal validAddress(_registry) {\r\n        registry = IContractRegistry(_registry);\r\n        prevRegistry = IContractRegistry(_registry);\r\n    }\r\n\r\n    /**\r\n      * @dev updates to the new contract-registry\r\n     */\r\n    function updateRegistry() public {\r\n        // verify that this function is permitted\r\n        require(msg.sender == owner || !onlyOwnerCanUpdateRegistry, \"ERR_ACCESS_DENIED\");\r\n\r\n        // get the new contract-registry\r\n        IContractRegistry newRegistry = IContractRegistry(addressOf(CONTRACT_REGISTRY));\r\n\r\n        // verify that the new contract-registry is different and not zero\r\n        require(newRegistry != address(registry) && newRegistry != address(0), \"ERR_INVALID_REGISTRY\");\r\n\r\n        // verify that the new contract-registry is pointing to a non-zero contract-registry\r\n        require(newRegistry.addressOf(CONTRACT_REGISTRY) != address(0), \"ERR_INVALID_REGISTRY\");\r\n\r\n        // save a backup of the current contract-registry before replacing it\r\n        prevRegistry = registry;\r\n\r\n        // replace the current contract-registry with the new contract-registry\r\n        registry = newRegistry;\r\n    }\r\n\r\n    /**\r\n      * @dev restores the previous contract-registry\r\n    */\r\n    function restoreRegistry() public ownerOnly {\r\n        // restore the previous contract-registry\r\n        registry = prevRegistry;\r\n    }\r\n\r\n    /**\r\n      * @dev restricts the permission to update the contract-registry\r\n      *\r\n      * @param _onlyOwnerCanUpdateRegistry  indicates whether or not permission is restricted to owner only\r\n    */\r\n    function restrictRegistryUpdate(bool _onlyOwnerCanUpdateRegistry) public ownerOnly {\r\n        // change the permission to update the contract-registry\r\n        onlyOwnerCanUpdateRegistry = _onlyOwnerCanUpdateRegistry;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the address associated with the given contract name\r\n      *\r\n      * @param _contractName    contract name\r\n      *\r\n      * @return contract address\r\n    */\r\n    function addressOf(bytes32 _contractName) internal view returns (address) {\r\n        return registry.addressOf(_contractName);\r\n    }\r\n}\r\n\r\n// File: contracts/utility/ReentrancyGuard.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/**\r\n  * @dev ReentrancyGuard\r\n  *\r\n  * The contract provides protection against re-entrancy - calling a function (directly or\r\n  * indirectly) from within itself.\r\n*/\r\ncontract ReentrancyGuard {\r\n    // true while protected code is being executed, false otherwise\r\n    bool private locked = false;\r\n\r\n    /**\r\n      * @dev ensures instantiation only by sub-contracts\r\n    */\r\n    constructor() internal {}\r\n\r\n    // protects a function against reentrancy attacks\r\n    modifier protected() {\r\n        _protected();\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _protected() internal view {\r\n        require(!locked, \"ERR_REENTRANCY\");\r\n    }\r\n}\r\n\r\n// File: contracts/utility/TokenHandler.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\ncontract TokenHandler {\r\n    bytes4 private constant APPROVE_FUNC_SELECTOR = bytes4(keccak256(\"approve(address,uint256)\"));\r\n    bytes4 private constant TRANSFER_FUNC_SELECTOR = bytes4(keccak256(\"transfer(address,uint256)\"));\r\n    bytes4 private constant TRANSFER_FROM_FUNC_SELECTOR = bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\r\n\r\n    /**\r\n      * @dev executes the ERC20 token's `approve` function and reverts upon failure\r\n      * the main purpose of this function is to prevent a non standard ERC20 token\r\n      * from failing silently\r\n      *\r\n      * @param _token   ERC20 token address\r\n      * @param _spender approved address\r\n      * @param _value   allowance amount\r\n    */\r\n    function safeApprove(IERC20Token _token, address _spender, uint256 _value) public {\r\n       execute(_token, abi.encodeWithSelector(APPROVE_FUNC_SELECTOR, _spender, _value));\r\n    }\r\n\r\n    /**\r\n      * @dev executes the ERC20 token's `transfer` function and reverts upon failure\r\n      * the main purpose of this function is to prevent a non standard ERC20 token\r\n      * from failing silently\r\n      *\r\n      * @param _token   ERC20 token address\r\n      * @param _to      target address\r\n      * @param _value   transfer amount\r\n    */\r\n    function safeTransfer(IERC20Token _token, address _to, uint256 _value) public {\r\n       execute(_token, abi.encodeWithSelector(TRANSFER_FUNC_SELECTOR, _to, _value));\r\n    }\r\n\r\n    /**\r\n      * @dev executes the ERC20 token's `transferFrom` function and reverts upon failure\r\n      * the main purpose of this function is to prevent a non standard ERC20 token\r\n      * from failing silently\r\n      *\r\n      * @param _token   ERC20 token address\r\n      * @param _from    source address\r\n      * @param _to      target address\r\n      * @param _value   transfer amount\r\n    */\r\n    function safeTransferFrom(IERC20Token _token, address _from, address _to, uint256 _value) public {\r\n       execute(_token, abi.encodeWithSelector(TRANSFER_FROM_FUNC_SELECTOR, _from, _to, _value));\r\n    }\r\n\r\n    /**\r\n      * @dev executes a function on the ERC20 token and reverts upon failure\r\n      * the main purpose of this function is to prevent a non standard ERC20 token\r\n      * from failing silently\r\n      *\r\n      * @param _token   ERC20 token address\r\n      * @param _data    data to pass in to the token's contract for execution\r\n    */\r\n    function execute(IERC20Token _token, bytes memory _data) private {\r\n        uint256[1] memory ret = [uint256(1)];\r\n\r\n        assembly {\r\n            let success := call(\r\n                gas,            // gas remaining\r\n                _token,         // destination address\r\n                0,              // no ether\r\n                add(_data, 32), // input buffer (starts after the first 32 bytes in the `data` array)\r\n                mload(_data),   // input length (loaded from the first 32 bytes in the `data` array)\r\n                ret,            // output buffer\r\n                32              // output length\r\n            )\r\n            if iszero(success) {\r\n                revert(0, 0)\r\n            }\r\n        }\r\n\r\n        require(ret[0] != 0, \"ERR_TRANSFER_FAILED\");\r\n    }\r\n}\r\n\r\n// File: contracts/utility/TokenHolder.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n  * @dev We consider every contract to be a 'token holder' since it's currently not possible\r\n  * for a contract to deny receiving tokens.\r\n  *\r\n  * The TokenHolder's contract sole purpose is to provide a safety mechanism that allows\r\n  * the owner to send tokens that were sent to the contract by mistake back to their sender.\r\n  *\r\n  * Note that we use the non standard ERC-20 interface which has no return value for transfer\r\n  * in order to support both non standard as well as standard token contracts.\r\n  * see https://github.com/ethereum/solidity/issues/4116\r\n*/\r\ncontract TokenHolder is ITokenHolder, TokenHandler, Owned, Utils {\r\n    /**\r\n      * @dev withdraws tokens held by the contract and sends them to an account\r\n      * can only be called by the owner\r\n      *\r\n      * @param _token   ERC20 token contract address\r\n      * @param _to      account to receive the new amount\r\n      * @param _amount  amount to withdraw\r\n    */\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\r\n        public\r\n        ownerOnly\r\n        validAddress(_token)\r\n        validAddress(_to)\r\n        notThis(_to)\r\n    {\r\n        safeTransfer(_token, _to, _amount);\r\n    }\r\n}\r\n\r\n// File: contracts/utility/SafeMath.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/**\r\n  * @dev Library for basic math operations with overflow/underflow protection\r\n*/\r\nlibrary SafeMath {\r\n    /**\r\n      * @dev returns the sum of _x and _y, reverts if the calculation overflows\r\n      *\r\n      * @param _x   value 1\r\n      * @param _y   value 2\r\n      *\r\n      * @return sum\r\n    */\r\n    function add(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        require(z >= _x, \"ERR_OVERFLOW\");\r\n        return z;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the difference of _x minus _y, reverts if the calculation underflows\r\n      *\r\n      * @param _x   minuend\r\n      * @param _y   subtrahend\r\n      *\r\n      * @return difference\r\n    */\r\n    function sub(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        require(_x >= _y, \"ERR_UNDERFLOW\");\r\n        return _x - _y;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the product of multiplying _x by _y, reverts if the calculation overflows\r\n      *\r\n      * @param _x   factor 1\r\n      * @param _y   factor 2\r\n      *\r\n      * @return product\r\n    */\r\n    function mul(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        // gas optimization\r\n        if (_x == 0)\r\n            return 0;\r\n\r\n        uint256 z = _x * _y;\r\n        require(z / _x == _y, \"ERR_OVERFLOW\");\r\n        return z;\r\n    }\r\n\r\n    /**\r\n      * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n      *\r\n      * @param _x   dividend\r\n      * @param _y   divisor\r\n      *\r\n      * @return quotient\r\n    */\r\n    function div(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        require(_y > 0, \"ERR_DIVIDE_BY_ZERO\");\r\n        uint256 c = _x / _y;\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: contracts/token/interfaces/IEtherToken.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n/*\r\n    Ether Token interface\r\n*/\r\ncontract IEtherToken is IERC20Token {\r\n    function deposit() public payable;\r\n    function withdraw(uint256 _amount) public;\r\n    function depositTo(address _to) public payable;\r\n    function withdrawTo(address _to, uint256 _amount) public;\r\n}\r\n\r\n// File: contracts/token/interfaces/ISmartToken.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n\r\n/*\r\n    Smart Token interface\r\n*/\r\ncontract ISmartToken is IConverterAnchor, IERC20Token {\r\n    function disableTransfers(bool _disable) public;\r\n    function issue(address _to, uint256 _amount) public;\r\n    function destroy(address _from, uint256 _amount) public;\r\n}\r\n\r\n// File: contracts/bancorx/interfaces/IBancorX.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\ncontract IBancorX {\r\n    function token() public view returns (IERC20Token) {this;}\r\n    function xTransfer(bytes32 _toBlockchain, bytes32 _to, uint256 _amount, uint256 _id) public;\r\n    function getXTransferAmount(uint256 _xTransferId, address _for) public view returns (uint256);\r\n}\r\n\r\n// File: contracts/BancorNetwork.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// interface of older converters for backward compatibility\r\ncontract ILegacyConverter {\r\n    function change(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount, uint256 _minReturn) public returns (uint256);\r\n}\r\n\r\n/**\r\n  * @dev The BancorNetwork contract is the main entry point for Bancor token conversions.\r\n  * It also allows for the conversion of any token in the Bancor Network to any other token in a single\r\n  * transaction by providing a conversion path.\r\n  *\r\n  * A note on Conversion Path: Conversion path is a data structure that is used when converting a token\r\n  * to another token in the Bancor Network, when the conversion cannot necessarily be done by a single\r\n  * converter and might require multiple 'hops'.\r\n  * The path defines which converters should be used and what kind of conversion should be done in each step.\r\n  *\r\n  * The path format doesn't include complex structure; instead, it is represented by a single array\r\n  * in which each 'hop' is represented by a 2-tuple - converter anchor & target token.\r\n  * In addition, the first element is always the source token.\r\n  * The converter anchor is only used as a pointer to a converter (since converter addresses are more\r\n  * likely to change as opposed to anchor addresses).\r\n  *\r\n  * Format:\r\n  * [source token, converter anchor, target token, converter anchor, target token...]\r\n*/\r\ncontract BancorNetwork is IBancorNetwork, TokenHolder, ContractRegistryClient, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 private constant CONVERSION_FEE_RESOLUTION = 1000000;\r\n    uint256 private constant AFFILIATE_FEE_RESOLUTION = 1000000;\r\n    address private constant ETH_RESERVE_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    struct ConversionStep {\r\n        IConverter converter;\r\n        IConverterAnchor anchor;\r\n        IERC20Token sourceToken;\r\n        IERC20Token targetToken;\r\n        address beneficiary;\r\n        bool isV28OrHigherConverter;\r\n        bool processAffiliateFee;\r\n    }\r\n\r\n    uint256 public maxAffiliateFee = 30000;     // maximum affiliate-fee\r\n\r\n    mapping (address => bool) public etherTokens;       // list of all supported ether tokens\r\n\r\n    /**\r\n      * @dev triggered when a conversion between two tokens occurs\r\n      *\r\n      * @param _smartToken  anchor governed by the converter\r\n      * @param _fromToken   source ERC20 token\r\n      * @param _toToken     target ERC20 token\r\n      * @param _fromAmount  amount converted, in the source token\r\n      * @param _toAmount    amount returned, minus conversion fee\r\n      * @param _trader      wallet that initiated the trade\r\n    */\r\n    event Conversion(\r\n        address indexed _smartToken,\r\n        address indexed _fromToken,\r\n        address indexed _toToken,\r\n        uint256 _fromAmount,\r\n        uint256 _toAmount,\r\n        address _trader\r\n    );\r\n\r\n    /**\r\n      * @dev initializes a new BancorNetwork instance\r\n      *\r\n      * @param _registry    address of a contract registry contract\r\n    */\r\n    constructor(IContractRegistry _registry) ContractRegistryClient(_registry) public {\r\n        etherTokens[ETH_RESERVE_ADDRESS] = true;\r\n    }\r\n\r\n    /**\r\n      * @dev allows the owner to update the maximum affiliate-fee\r\n      *\r\n      * @param _maxAffiliateFee   maximum affiliate-fee\r\n    */\r\n    function setMaxAffiliateFee(uint256 _maxAffiliateFee)\r\n        public\r\n        ownerOnly\r\n    {\r\n        require(_maxAffiliateFee <= AFFILIATE_FEE_RESOLUTION, \"ERR_INVALID_AFFILIATE_FEE\");\r\n        maxAffiliateFee = _maxAffiliateFee;\r\n    }\r\n\r\n    /**\r\n      * @dev allows the owner to register/unregister ether tokens\r\n      *\r\n      * @param _token       ether token contract address\r\n      * @param _register    true to register, false to unregister\r\n    */\r\n    function registerEtherToken(IEtherToken _token, bool _register)\r\n        public\r\n        ownerOnly\r\n        validAddress(_token)\r\n        notThis(_token)\r\n    {\r\n        etherTokens[_token] = _register;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the conversion path between two tokens in the network\r\n      * note that this method is quite expensive in terms of gas and should generally be called off-chain\r\n      *\r\n      * @param _sourceToken source token address\r\n      * @param _targetToken target token address\r\n      *\r\n      * @return conversion path between the two tokens\r\n    */\r\n    function conversionPath(IERC20Token _sourceToken, IERC20Token _targetToken) public view returns (address[]) {\r\n        IConversionPathFinder pathFinder = IConversionPathFinder(addressOf(CONVERSION_PATH_FINDER));\r\n        return pathFinder.findPath(_sourceToken, _targetToken);\r\n    }\r\n\r\n    /**\r\n      * @dev returns the expected rate of converting a given amount on a given path\r\n      * note that there is no support for circular paths\r\n      *\r\n      * @param _path        conversion path (see conversion path format above)\r\n      * @param _amount      amount of _path[0] tokens received from the sender\r\n      *\r\n      * @return expected rate\r\n    */\r\n    function rateByPath(IERC20Token[] _path, uint256 _amount) public view returns (uint256) {\r\n        uint256 amount;\r\n        uint256 fee;\r\n        uint256 supply;\r\n        uint256 balance;\r\n        uint32 weight;\r\n        IConverter converter;\r\n        IBancorFormula formula = IBancorFormula(addressOf(BANCOR_FORMULA));\r\n\r\n        amount = _amount;\r\n\r\n        // verify that the number of elements is larger than 2 and odd\r\n        require(_path.length > 2 && _path.length % 2 == 1, \"ERR_INVALID_PATH\");\r\n\r\n        // iterate over the conversion path\r\n        for (uint256 i = 2; i < _path.length; i += 2) {\r\n            IERC20Token sourceToken = _path[i - 2];\r\n            IERC20Token anchor = _path[i - 1];\r\n            IERC20Token targetToken = _path[i];\r\n\r\n            if (targetToken == anchor) { // buy the smart token\r\n                // check if the current smart token has changed\r\n                if (i < 3 || anchor != _path[i - 3]) {\r\n                    supply = ISmartToken(anchor).totalSupply();\r\n                    converter = IConverter(IConverterAnchor(anchor).owner());\r\n                }\r\n\r\n                // get the amount & the conversion fee\r\n                balance = converter.getConnectorBalance(sourceToken);\r\n                (, weight, , , ) = converter.connectors(sourceToken);\r\n                amount = formula.purchaseRate(supply, balance, weight, amount);\r\n                fee = amount.mul(converter.conversionFee()).div(CONVERSION_FEE_RESOLUTION);\r\n                amount -= fee;\r\n\r\n                // update the smart token supply for the next iteration\r\n                supply = supply.add(amount);\r\n            }\r\n            else if (sourceToken == anchor) { // sell the smart token\r\n                // check if the current smart token has changed\r\n                if (i < 3 || anchor != _path[i - 3]) {\r\n                    supply = ISmartToken(anchor).totalSupply();\r\n                    converter = IConverter(IConverterAnchor(anchor).owner());\r\n                }\r\n\r\n                // get the amount & the conversion fee\r\n                balance = converter.getConnectorBalance(targetToken);\r\n                (, weight, , , ) = converter.connectors(targetToken);\r\n                amount = formula.saleRate(supply, balance, weight, amount);\r\n                fee = amount.mul(converter.conversionFee()).div(CONVERSION_FEE_RESOLUTION);\r\n                amount -= fee;\r\n\r\n                // update the smart token supply for the next iteration\r\n                supply = supply.sub(amount);\r\n            }\r\n            else { // cross reserve conversion\r\n                // check if the current smart token has changed\r\n                if (i < 3 || anchor != _path[i - 3]) {\r\n                    converter = IConverter(IConverterAnchor(anchor).owner());\r\n                }\r\n\r\n                (amount, fee) = getReturn(converter, sourceToken, targetToken, amount);\r\n            }\r\n        }\r\n\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n      * @dev converts the token to any other token in the bancor network by following\r\n      * a predefined conversion path and transfers the result tokens to a target account\r\n      * affiliate account/fee can also be passed in to receive a conversion fee (on top of the liquidity provider fees)\r\n      * note that the network should already have been given allowance of the source token (if not ETH)\r\n      *\r\n      * @param _path                conversion path, see conversion path format above\r\n      * @param _amount              amount to convert from, in the source token\r\n      * @param _minReturn           if the conversion results in an amount smaller than the minimum return - it is cancelled, must be greater than zero\r\n      * @param _beneficiary         account that will receive the conversion result or 0x0 to send the result to the sender account\r\n      * @param _affiliateAccount    wallet address to receive the affiliate fee or 0x0 to disable affiliate fee\r\n      * @param _affiliateFee        affiliate fee in PPM or 0 to disable affiliate fee\r\n      *\r\n      * @return amount of tokens received from the conversion\r\n    */\r\n    function convertByPath(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _beneficiary, address _affiliateAccount, uint256 _affiliateFee)\r\n        public\r\n        payable\r\n        protected\r\n        greaterThanZero(_minReturn)\r\n        returns (uint256)\r\n    {\r\n        // verify that the path contrains at least a single 'hop' and that the number of elements is odd\r\n        require(_path.length > 2 && _path.length % 2 == 1, \"ERR_INVALID_PATH\");\r\n\r\n        // validate msg.value and prepare the source token for the conversion\r\n        handleSourceToken(_path[0], IConverterAnchor(_path[1]), _amount);\r\n\r\n        // check if affiliate fee is enabled\r\n        bool affiliateFeeEnabled = false;\r\n        if (address(_affiliateAccount) == 0) {\r\n            require(_affiliateFee == 0, \"ERR_INVALID_AFFILIATE_FEE\");\r\n        }\r\n        else {\r\n            require(0 < _affiliateFee && _affiliateFee <= maxAffiliateFee, \"ERR_INVALID_AFFILIATE_FEE\");\r\n            affiliateFeeEnabled = true;\r\n        }\r\n\r\n        // check if beneficiary is set\r\n        address beneficiary = msg.sender;\r\n        if (_beneficiary != address(0))\r\n            beneficiary = _beneficiary;\r\n\r\n        // convert and get the resulting amount\r\n        ConversionStep[] memory data = createConversionData(_path, beneficiary, affiliateFeeEnabled);\r\n        uint256 amount = doConversion(data, _amount, _minReturn, _affiliateAccount, _affiliateFee);\r\n\r\n        // handle the conversion target tokens\r\n        handleTargetToken(data, amount, beneficiary);\r\n\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n      * @dev converts any other token to BNT in the bancor network by following\r\n      a predefined conversion path and transfers the result to an account on a different blockchain\r\n      * note that the network should already have been given allowance of the source token (if not ETH)\r\n      *\r\n      * @param _path                conversion path, see conversion path format above\r\n      * @param _amount              amount to convert from, in the source token\r\n      * @param _minReturn           if the conversion results in an amount smaller than the minimum return - it is cancelled, must be greater than zero\r\n      * @param _targetBlockchain    blockchain BNT will be issued on\r\n      * @param _targetAccount       address/account on the target blockchain to send the BNT to\r\n      * @param _conversionId        pre-determined unique (if non zero) id which refers to this transaction\r\n      *\r\n      * @return the amount of BNT received from this conversion\r\n    */\r\n    function xConvert(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        bytes32 _targetBlockchain,\r\n        bytes32 _targetAccount,\r\n        uint256 _conversionId\r\n    )\r\n        public\r\n        payable\r\n        returns (uint256)\r\n    {\r\n        return xConvert2(_path, _amount, _minReturn, _targetBlockchain, _targetAccount, _conversionId, address(0), 0);\r\n    }\r\n\r\n    /**\r\n      * @dev converts any other token to BNT in the bancor network by following\r\n      a predefined conversion path and transfers the result to an account on a different blockchain\r\n      * note that the network should already have been given allowance of the source token (if not ETH)\r\n      *\r\n      * @param _path                conversion path, see conversion path format above\r\n      * @param _amount              amount to convert from, in the source token\r\n      * @param _minReturn           if the conversion results in an amount smaller than the minimum return - it is cancelled, must be greater than zero\r\n      * @param _targetBlockchain    blockchain BNT will be issued on\r\n      * @param _targetAccount       address/account on the target blockchain to send the BNT to\r\n      * @param _conversionId        pre-determined unique (if non zero) id which refers to this transaction\r\n      * @param _affiliateAccount    affiliate account\r\n      * @param _affiliateFee        affiliate fee in PPM\r\n      *\r\n      * @return the amount of BNT received from this conversion\r\n    */\r\n    function xConvert2(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        bytes32 _targetBlockchain,\r\n        bytes32 _targetAccount,\r\n        uint256 _conversionId,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    )\r\n        public\r\n        payable\r\n        greaterThanZero(_minReturn)\r\n        returns (uint256)\r\n    {\r\n        IERC20Token targetToken = _path[_path.length - 1];\r\n        IBancorX bancorX = IBancorX(addressOf(BANCOR_X));\r\n\r\n        // verify that the destination token is BNT\r\n        require(targetToken == addressOf(BNT_TOKEN), \"ERR_INVALID_TARGET_TOKEN\");\r\n\r\n        // convert and get the resulting amount\r\n        uint256 amount = convertByPath(_path, _amount, _minReturn, this, _affiliateAccount, _affiliateFee);\r\n\r\n        // grant BancorX allowance\r\n        ensureAllowance(targetToken, bancorX, amount);\r\n\r\n        // transfer the resulting amount to BancorX\r\n        bancorX.xTransfer(_targetBlockchain, _targetAccount, amount, _conversionId);\r\n\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n      * @dev allows a user to convert a token that was sent from another blockchain into any other\r\n      * token on the BancorNetwork\r\n      * ideally this transaction is created before the previous conversion is even complete, so\r\n      * so the input amount isn't known at that point - the amount is actually take from the\r\n      * BancorX contract directly by specifying the conversion id\r\n      *\r\n      * @param _path            conversion path\r\n      * @param _bancorX         address of the BancorX contract for the source token\r\n      * @param _conversionId    pre-determined unique (if non zero) id which refers to this conversion\r\n      * @param _minReturn       if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\r\n      * @param _beneficiary     wallet to receive the conversion result\r\n      *\r\n      * @return amount of tokens received from the conversion\r\n    */\r\n    function completeXConversion(IERC20Token[] _path, IBancorX _bancorX, uint256 _conversionId, uint256 _minReturn, address _beneficiary)\r\n        public returns (uint256)\r\n    {\r\n        // verify that the source token is the BancorX token\r\n        require(_path[0] == _bancorX.token(), \"ERR_INVALID_SOURCE_TOKEN\");\r\n\r\n        // get conversion amount from BancorX contract\r\n        uint256 amount = _bancorX.getXTransferAmount(_conversionId, msg.sender);\r\n\r\n        // perform the conversion\r\n        return convertByPath(_path, amount, _minReturn, _beneficiary, address(0), 0);\r\n    }\r\n\r\n    /**\r\n      * @dev executes the actual conversion by following the conversion path\r\n      *\r\n      * @param _data                conversion data, see ConversionStep struct above\r\n      * @param _amount              amount to convert from, in the source token\r\n      * @param _minReturn           if the conversion results in an amount smaller than the minimum return - it is cancelled, must be greater than zero\r\n      * @param _affiliateAccount    affiliate account\r\n      * @param _affiliateFee        affiliate fee in PPM\r\n      *\r\n      * @return amount of tokens received from the conversion\r\n    */\r\n    function doConversion(\r\n        ConversionStep[] _data,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    ) private returns (uint256) {\r\n        uint256 toAmount;\r\n        uint256 fromAmount = _amount;\r\n\r\n        // iterate over the conversion data\r\n        for (uint256 i = 0; i < _data.length; i++) {\r\n            ConversionStep memory stepData = _data[i];\r\n\r\n            // newer converter\r\n            if (stepData.isV28OrHigherConverter) {\r\n                // transfer the tokens to the converter only if the network contract currently holds the tokens\r\n                // not needed with ETH or if it's the first conversion step\r\n                if (i != 0 && _data[i - 1].beneficiary == address(this) && !etherTokens[stepData.sourceToken])\r\n                    safeTransfer(stepData.sourceToken, stepData.converter, fromAmount);\r\n            }\r\n            // older converter\r\n            // if the source token is the smart token, no need to do any transfers as the converter controls it\r\n            else if (stepData.sourceToken != ISmartToken(stepData.anchor)) {\r\n                // grant allowance for it to transfer the tokens from the network contract\r\n                ensureAllowance(stepData.sourceToken, stepData.converter, fromAmount);\r\n            }\r\n\r\n            // do the conversion\r\n            if (!stepData.isV28OrHigherConverter)\r\n                toAmount = ILegacyConverter(stepData.converter).change(stepData.sourceToken, stepData.targetToken, fromAmount, 1);\r\n            else if (etherTokens[stepData.sourceToken])\r\n                toAmount = stepData.converter.convert.value(msg.value)(stepData.sourceToken, stepData.targetToken, fromAmount, msg.sender, stepData.beneficiary);\r\n            else\r\n                toAmount = stepData.converter.convert(stepData.sourceToken, stepData.targetToken, fromAmount, msg.sender, stepData.beneficiary);\r\n\r\n            // pay affiliate-fee if needed\r\n            if (stepData.processAffiliateFee) {\r\n                uint256 affiliateAmount = toAmount.mul(_affiliateFee).div(AFFILIATE_FEE_RESOLUTION);\r\n                require(stepData.targetToken.transfer(_affiliateAccount, affiliateAmount), \"ERR_FEE_TRANSFER_FAILED\");\r\n                toAmount -= affiliateAmount;\r\n            }\r\n\r\n            emit Conversion(stepData.anchor, stepData.sourceToken, stepData.targetToken, fromAmount, toAmount, msg.sender);\r\n            fromAmount = toAmount;\r\n        }\r\n\r\n        // ensure the trade meets the minimum requested amount\r\n        require(toAmount >= _minReturn, \"ERR_RETURN_TOO_LOW\");\r\n\r\n        return toAmount;\r\n    }\r\n\r\n    /**\r\n      * @dev validates msg.value and prepares the conversion source token for the conversion\r\n      *\r\n      * @param _sourceToken source token of the first conversion step\r\n      * @param _anchor      converter anchor of the first conversion step\r\n      * @param _amount      amount to convert from, in the source token\r\n    */\r\n    function handleSourceToken(IERC20Token _sourceToken, IConverterAnchor _anchor, uint256 _amount) private {\r\n        IConverter firstConverter = IConverter(_anchor.owner());\r\n        bool isNewerConverter = isV28OrHigherConverter(firstConverter);\r\n\r\n        // ETH\r\n        if (msg.value > 0) {\r\n            // validate msg.value\r\n            require(msg.value == _amount, \"ERR_ETH_AMOUNT_MISMATCH\");\r\n\r\n            // EtherToken converter - deposit the ETH into the EtherToken\r\n            // note that it can still be a non ETH converter if the path is wrong\r\n            // but such conversion will simply revert\r\n            if (!isNewerConverter)\r\n                IEtherToken(getConverterEtherTokenAddress(firstConverter)).deposit.value(msg.value)();\r\n        }\r\n        // EtherToken\r\n        else if (etherTokens[_sourceToken]) {\r\n            // claim the tokens - if the source token is ETH reserve, this call will fail\r\n            // since in that case the transaction must be sent with msg.value\r\n            safeTransferFrom(_sourceToken, msg.sender, this, _amount);\r\n\r\n            // ETH converter - withdraw the ETH\r\n            if (isNewerConverter)\r\n                IEtherToken(_sourceToken).withdraw(_amount);\r\n        }\r\n        // other ERC20 token\r\n        else {\r\n            // newer converter - transfer the tokens from the sender directly to the converter\r\n            // otherwise claim the tokens\r\n            if (isNewerConverter)\r\n                safeTransferFrom(_sourceToken, msg.sender, firstConverter, _amount);\r\n            else\r\n                safeTransferFrom(_sourceToken, msg.sender, this, _amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n      * @dev handles the conversion target token if the network still holds it at the end of the conversion\r\n      *\r\n      * @param _data        conversion data, see ConversionStep struct above\r\n      * @param _amount      conversion return amount, in the target token\r\n      * @param _beneficiary wallet to receive the conversion result\r\n    */\r\n    function handleTargetToken(ConversionStep[] _data, uint256 _amount, address _beneficiary) private {\r\n        ConversionStep memory stepData = _data[_data.length - 1];\r\n\r\n        // network contract doesn't hold the tokens, do nothing\r\n        if (stepData.beneficiary != address(this))\r\n            return;\r\n\r\n        IERC20Token targetToken = stepData.targetToken;\r\n\r\n        // ETH / EtherToken\r\n        if (etherTokens[targetToken]) {\r\n            // newer converter should send ETH directly to the beneficiary\r\n            assert(!stepData.isV28OrHigherConverter);\r\n\r\n            // EtherToken converter - withdraw the ETH and transfer to the beneficiary\r\n            IEtherToken(targetToken).withdrawTo(_beneficiary, _amount);\r\n        }\r\n        // other ERC20 token\r\n        else {\r\n            safeTransfer(targetToken, _beneficiary, _amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n      * @dev creates a memory cache of all conversion steps data to minimize logic and external calls during conversions\r\n      *\r\n      * @param _conversionPath      conversion path, see conversion path format above\r\n      * @param _beneficiary         wallet to receive the conversion result\r\n      * @param _affiliateFeeEnabled true if affiliate fee was requested by the sender, false if not\r\n      *\r\n      * @return cached conversion data to be ingested later on by the conversion flow\r\n    */\r\n    function createConversionData(IERC20Token[] _conversionPath, address _beneficiary, bool _affiliateFeeEnabled) private view returns (ConversionStep[]) {\r\n        ConversionStep[] memory data = new ConversionStep[](_conversionPath.length / 2);\r\n\r\n        bool affiliateFeeProcessed = false;\r\n        address bntToken = addressOf(BNT_TOKEN);\r\n        // iterate the conversion path and create the conversion data for each step\r\n        uint256 i;\r\n        for (i = 0; i < _conversionPath.length - 1; i += 2) {\r\n            IConverterAnchor anchor = IConverterAnchor(_conversionPath[i + 1]);\r\n            IConverter converter = IConverter(anchor.owner());\r\n            IERC20Token targetToken = _conversionPath[i + 2];\r\n\r\n            // check if the affiliate fee should be processed in this step\r\n            bool processAffiliateFee = _affiliateFeeEnabled && !affiliateFeeProcessed && targetToken == bntToken;\r\n            if (processAffiliateFee)\r\n                affiliateFeeProcessed = true;\r\n\r\n            data[i / 2] = ConversionStep({\r\n                // set the converter anchor\r\n                anchor: anchor,\r\n\r\n                // set the converter\r\n                converter: converter,\r\n\r\n                // set the source/target tokens\r\n                sourceToken: _conversionPath[i],\r\n                targetToken: targetToken,\r\n\r\n                // requires knowledge about the next step, so initialize in the next phase\r\n                beneficiary: address(0),\r\n\r\n                // set flags\r\n                isV28OrHigherConverter: isV28OrHigherConverter(converter),\r\n                processAffiliateFee: processAffiliateFee\r\n            });\r\n        }\r\n\r\n        // ETH support\r\n        // source is ETH\r\n        ConversionStep memory stepData = data[0];\r\n        if (etherTokens[stepData.sourceToken]) {\r\n            // newer converter - replace the source token address with ETH reserve address\r\n            if (stepData.isV28OrHigherConverter)\r\n                stepData.sourceToken = IERC20Token(ETH_RESERVE_ADDRESS);\r\n            // older converter - replace the source token with the EtherToken address used by the converter\r\n            else\r\n                stepData.sourceToken = IERC20Token(getConverterEtherTokenAddress(stepData.converter));\r\n        }\r\n\r\n        // target is ETH\r\n        stepData = data[data.length - 1];\r\n        if (etherTokens[stepData.targetToken]) {\r\n            // newer converter - replace the target token address with ETH reserve address\r\n            if (stepData.isV28OrHigherConverter)\r\n                stepData.targetToken = IERC20Token(ETH_RESERVE_ADDRESS);\r\n            // older converter - replace the target token with the EtherToken address used by the converter\r\n            else\r\n                stepData.targetToken = IERC20Token(getConverterEtherTokenAddress(stepData.converter));\r\n        }\r\n\r\n        // set the beneficiary for each step\r\n        for (i = 0; i < data.length; i++) {\r\n            stepData = data[i];\r\n\r\n            // first check if the converter in this step is newer as older converters don't even support the beneficiary argument\r\n            if (stepData.isV28OrHigherConverter) {\r\n                // if affiliate fee is processed in this step, beneficiary is the network contract\r\n                if (stepData.processAffiliateFee)\r\n                    stepData.beneficiary = this;\r\n                // if it's the last step, beneficiary is the final beneficiary\r\n                else if (i == data.length - 1)\r\n                    stepData.beneficiary = _beneficiary;\r\n                // if the converter in the next step is newer, beneficiary is the next converter\r\n                else if (data[i + 1].isV28OrHigherConverter)\r\n                    stepData.beneficiary = data[i + 1].converter;\r\n                // the converter in the next step is older, beneficiary is the network contract\r\n                else\r\n                    stepData.beneficiary = this;\r\n            }\r\n            else {\r\n                // converter in this step is older, beneficiary is the network contract\r\n                stepData.beneficiary = this;\r\n            }\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n      * @dev utility, checks whether allowance for the given spender exists and approves one if it doesn't.\r\n      * Note that we use the non standard erc-20 interface in which `approve` has no return value so that\r\n      * this function will work for both standard and non standard tokens\r\n      *\r\n      * @param _token   token to check the allowance in\r\n      * @param _spender approved address\r\n      * @param _value   allowance amount\r\n    */\r\n    function ensureAllowance(IERC20Token _token, address _spender, uint256 _value) private {\r\n        uint256 allowance = _token.allowance(this, _spender);\r\n        if (allowance < _value) {\r\n            if (allowance > 0)\r\n                safeApprove(_token, _spender, 0);\r\n            safeApprove(_token, _spender, _value);\r\n        }\r\n    }\r\n\r\n    // legacy - returns the address of an EtherToken used by the converter\r\n    function getConverterEtherTokenAddress(IConverter _converter) private view returns (address) {\r\n        uint256 reserveCount = _converter.connectorTokenCount();\r\n        for (uint256 i = 0; i < reserveCount; i++) {\r\n            address reserveTokenAddress = _converter.connectorTokens(i);\r\n            if (etherTokens[reserveTokenAddress])\r\n                return reserveTokenAddress;\r\n        }\r\n\r\n        return ETH_RESERVE_ADDRESS;\r\n    }\r\n\r\n    bytes4 private constant GET_RETURN_FUNC_SELECTOR = bytes4(keccak256(\"getReturn(address,address,uint256)\"));\r\n\r\n    // using assembly code since older converter versions have different return values\r\n    function getReturn(address _dest, address _sourceToken, address _targetToken, uint256 _amount) internal view returns (uint256, uint256) {\r\n        uint256[2] memory ret;\r\n        bytes memory data = abi.encodeWithSelector(GET_RETURN_FUNC_SELECTOR, _sourceToken, _targetToken, _amount);\r\n\r\n        assembly {\r\n            let success := staticcall(\r\n                gas,           // gas remaining\r\n                _dest,         // destination address\r\n                add(data, 32), // input buffer (starts after the first 32 bytes in the `data` array)\r\n                mload(data),   // input length (loaded from the first 32 bytes in the `data` array)\r\n                ret,           // output buffer\r\n                64             // output length\r\n            )\r\n            if iszero(success) {\r\n                revert(0, 0)\r\n            }\r\n        }\r\n\r\n        return (ret[0], ret[1]);\r\n    }\r\n\r\n    bytes4 private constant IS_V28_OR_HIGHER_FUNC_SELECTOR = bytes4(keccak256(\"isV28OrHigher()\"));\r\n\r\n    // using assembly code to identify converter version\r\n    // can't rely on the version number since the function had a different signature in older converters\r\n    function isV28OrHigherConverter(IConverter _converter) internal view returns (bool) {\r\n        bool success;\r\n        uint256[1] memory ret;\r\n        bytes memory data = abi.encodeWithSelector(IS_V28_OR_HIGHER_FUNC_SELECTOR);\r\n\r\n        assembly {\r\n            success := staticcall(\r\n                gas,           // gas remaining\r\n                _converter,    // destination address\r\n                add(data, 32), // input buffer (starts after the first 32 bytes in the `data` array)\r\n                mload(data),   // input length (loaded from the first 32 bytes in the `data` array)\r\n                ret,           // output buffer\r\n                32             // output length\r\n            )\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function getReturnByPath(IERC20Token[] _path, uint256 _amount) public view returns (uint256, uint256) {\r\n        return (rateByPath(_path, _amount), 0);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function convert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn) public payable returns (uint256) {\r\n        return convertByPath(_path, _amount, _minReturn, address(0), address(0), 0);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function convert2(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    )\r\n        public\r\n        payable\r\n        returns (uint256)\r\n    {\r\n        return convertByPath(_path, _amount, _minReturn, address(0), _affiliateAccount, _affiliateFee);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function convertFor(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _beneficiary) public payable returns (uint256) {\r\n        return convertByPath(_path, _amount, _minReturn, _beneficiary, address(0), 0);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function convertFor2(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _beneficiary,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    )\r\n        public\r\n        payable\r\n        greaterThanZero(_minReturn)\r\n        returns (uint256)\r\n    {\r\n        return convertByPath(_path, _amount, _minReturn, _beneficiary, _affiliateAccount, _affiliateFee);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function claimAndConvert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn) public returns (uint256) {\r\n        return convertByPath(_path, _amount, _minReturn, address(0), address(0), 0);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function claimAndConvert2(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    )\r\n        public\r\n        returns (uint256)\r\n    {\r\n        return convertByPath(_path, _amount, _minReturn, address(0), _affiliateAccount, _affiliateFee);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function claimAndConvertFor(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _beneficiary) public returns (uint256) {\r\n        return convertByPath(_path, _amount, _minReturn, _beneficiary, address(0), 0);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function claimAndConvertFor2(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _beneficiary,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    )\r\n        public\r\n        returns (uint256)\r\n    {\r\n        return convertByPath(_path, _amount, _minReturn, _beneficiary, _affiliateAccount, _affiliateFee);\r\n    }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_onlyOwnerCanUpdateRegistry\",\"type\":\"bool\"}],\"name\":\"restrictRegistryUpdate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_register\",\"type\":\"bool\"}],\"name\":\"registerEtherToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_path\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getReturnByPath\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_path\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_minReturn\",\"type\":\"uint256\"},{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_affiliateAccount\",\"type\":\"address\"},{\"name\":\"_affiliateFee\",\"type\":\"uint256\"}],\"name\":\"claimAndConvertFor2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"onlyOwnerCanUpdateRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_path\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_minReturn\",\"type\":\"uint256\"},{\"name\":\"_affiliateAccount\",\"type\":\"address\"},{\"name\":\"_affiliateFee\",\"type\":\"uint256\"}],\"name\":\"convert2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxAffiliateFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prevRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_path\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"rateByPath\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"etherTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_path\",\"type\":\"address[]\"},{\"name\":\"_bancorX\",\"type\":\"address\"},{\"name\":\"_conversionId\",\"type\":\"uint256\"},{\"name\":\"_minReturn\",\"type\":\"uint256\"},{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"completeXConversion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_path\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_minReturn\",\"type\":\"uint256\"},{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_affiliateAccount\",\"type\":\"address\"},{\"name\":\"_affiliateFee\",\"type\":\"uint256\"}],\"name\":\"convertFor2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_path\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_minReturn\",\"type\":\"uint256\"},{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"claimAndConvertFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"restoreRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_path\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_minReturn\",\"type\":\"uint256\"},{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_affiliateAccount\",\"type\":\"address\"},{\"name\":\"_affiliateFee\",\"type\":\"uint256\"}],\"name\":\"convertByPath\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_path\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_minReturn\",\"type\":\"uint256\"},{\"name\":\"_targetBlockchain\",\"type\":\"bytes32\"},{\"name\":\"_targetAccount\",\"type\":\"bytes32\"},{\"name\":\"_conversionId\",\"type\":\"uint256\"}],\"name\":\"xConvert\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_path\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_minReturn\",\"type\":\"uint256\"}],\"name\":\"claimAndConvert\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_path\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_minReturn\",\"type\":\"uint256\"},{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"convertFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_path\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_minReturn\",\"type\":\"uint256\"},{\"name\":\"_targetBlockchain\",\"type\":\"bytes32\"},{\"name\":\"_targetAccount\",\"type\":\"bytes32\"},{\"name\":\"_conversionId\",\"type\":\"uint256\"},{\"name\":\"_affiliateAccount\",\"type\":\"address\"},{\"name\":\"_affiliateFee\",\"type\":\"uint256\"}],\"name\":\"xConvert2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"safeTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sourceToken\",\"type\":\"address\"},{\"name\":\"_targetToken\",\"type\":\"address\"}],\"name\":\"conversionPath\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_path\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_minReturn\",\"type\":\"uint256\"},{\"name\":\"_affiliateAccount\",\"type\":\"address\"},{\"name\":\"_affiliateFee\",\"type\":\"uint256\"}],\"name\":\"claimAndConvert2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"safeApprove\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_path\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_minReturn\",\"type\":\"uint256\"}],\"name\":\"convert\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxAffiliateFee\",\"type\":\"uint256\"}],\"name\":\"setMaxAffiliateFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_registry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_smartToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_fromToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_toToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_fromAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_toAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_trader\",\"type\":\"address\"}],\"name\":\"Conversion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"}]", "ContractName": "BancorNetwork", "CompilerVersion": "v0.4.26+commit.4563c3fc", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000052ae12abe5d8bd778bd5397f99ca900624cfadd4", "EVMVersion": "Default", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://d88f3ac021a9aa4df260d5e6deb758ddaac9b6f0cdf1851d84c328c2f2195abb"}