{"SourceCode": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address account) external view returns (uint);\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Governance {\r\n\r\n  // The duration of voting on a proposal\r\n  uint public constant votingPeriod = 86000;\r\n\r\n  // Time since submission before the proposal can be executed\r\n  uint public constant executionPeriod = 86000 * 2;\r\n\r\n  // The required minimum number of votes in support of a proposal for it to succeed\r\n  uint public constant quorumVotes = 5000e18;\r\n\r\n  // The minimum number of votes required for an account to create a proposal\r\n  uint public constant proposalThreshold = 100e18;\r\n\r\n  IERC20 public votingToken;\r\n\r\n  // The total number of proposals\r\n  uint public proposalCount;\r\n\r\n  // The record of all proposals ever proposed\r\n  mapping (uint => Proposal) public proposals;\r\n\r\n  // receipts[ProposalId][voter]\r\n  mapping (uint => mapping (address => Receipt)) public receipts;\r\n\r\n  // The time until which tokens used for voting will be locked\r\n  mapping (address => uint) public voteLock;\r\n\r\n  // Keeps track of locked tokens per address\r\n  mapping(address => uint) public balanceOf;\r\n\r\n  struct Proposal {\r\n    // Unique id for looking up a proposal\r\n    uint id;\r\n\r\n    // Creator of the proposal\r\n    address proposer;\r\n\r\n    // The time at which voting starts\r\n    uint startTime;\r\n\r\n    // Current number of votes in favor of this proposal\r\n    uint forVotes;\r\n\r\n    // Current number of votes in opposition to this proposal\r\n    uint againstVotes;\r\n\r\n    // Queued transaction hash\r\n    bytes32 txHash;\r\n\r\n    bool executed;\r\n  }\r\n\r\n  // Ballot receipt record for a voter\r\n  struct Receipt {\r\n    // Whether or not a vote has been cast\r\n    bool hasVoted;\r\n\r\n    // Whether or not the voter supports the proposal\r\n    bool support;\r\n\r\n    // The number of votes the voter had, which were cast\r\n    uint votes;\r\n  }\r\n\r\n  // Possible states that a proposal may be in\r\n  enum ProposalState {\r\n    Active,            // 0\r\n    Defeated,          // 1\r\n    PendingExecution,  // 2\r\n    ReadyForExecution, // 3\r\n    Executed           // 4\r\n  }\r\n\r\n  // If the votingPeriod is changed and the user votes again, the lock period will be reset.\r\n  modifier lockVotes() {\r\n    uint tokenBalance = votingToken.balanceOf(msg.sender);\r\n    votingToken.transferFrom(msg.sender, address(this), tokenBalance);\r\n    _mint(msg.sender, tokenBalance);\r\n    voteLock[msg.sender] = block.timestamp + votingPeriod;\r\n    _;\r\n  }\r\n\r\n  constructor(IERC20 _votingToken) {\r\n      votingToken = _votingToken;\r\n  }\r\n\r\n  function state(uint proposalId) public view returns (ProposalState) {\r\n    require(proposalCount >= proposalId && proposalId > 0, \"Governance::state: invalid proposal id\");\r\n    Proposal storage proposal = proposals[proposalId];\r\n\r\n    if (block.timestamp <= proposal.startTime + votingPeriod) {\r\n      return ProposalState.Active;\r\n\r\n    } else if (proposal.executed == true) {\r\n      return ProposalState.Executed;\r\n\r\n    } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes) {\r\n      return ProposalState.Defeated;\r\n\r\n    } else if (block.timestamp < proposal.startTime + executionPeriod) {\r\n      return ProposalState.PendingExecution;\r\n\r\n    } else {\r\n      return ProposalState.ReadyForExecution;\r\n    }\r\n  }\r\n\r\n  function execute(uint _proposalId, address _target, bytes memory _data)\r\n    public\r\n    payable\r\n    returns (bytes memory)\r\n  {\r\n    bytes32 txHash = keccak256(abi.encode(_target, _data));\r\n    Proposal storage proposal = proposals[_proposalId];\r\n    require(proposal.txHash == txHash, \"Governance::execute: Invalid proposal\");\r\n    require(state(_proposalId) == ProposalState.ReadyForExecution, \"Governance::execute: Cannot be executed\");\r\n\r\n    (bool success, bytes memory returnData) = _target.delegatecall(_data);\r\n    require(success, \"Governance::execute: Transaction execution reverted.\");\r\n    proposal.executed = true;\r\n\r\n    return returnData;\r\n  }\r\n\r\n  function propose(address _target, bytes memory _data) public lockVotes returns (uint) {\r\n\r\n    require(balanceOf[msg.sender] >= proposalThreshold, \"Governance::propose: proposer votes below proposal threshold\");\r\n\r\n    bytes32 txHash = keccak256(abi.encode(_target, _data));\r\n\r\n    proposalCount++;\r\n    Proposal memory newProposal = Proposal({\r\n      id:           proposalCount,\r\n      proposer:     msg.sender,\r\n      startTime:    block.timestamp,\r\n      forVotes:     0,\r\n      againstVotes: 0,\r\n      txHash:       txHash,\r\n      executed:     false\r\n    });\r\n\r\n    proposals[newProposal.id] = newProposal;\r\n\r\n    return proposalCount;\r\n  }\r\n\r\n  function vote(uint _proposalId, bool _support) public lockVotes {\r\n\r\n    require(state(_proposalId) == ProposalState.Active, \"Governance::vote: voting is closed\");\r\n    Proposal storage proposal = proposals[_proposalId];\r\n    Receipt storage receipt = receipts[_proposalId][msg.sender];\r\n    require(receipt.hasVoted == false, \"Governance::vote: voter already voted\");\r\n\r\n    uint votes = balanceOf[msg.sender];\r\n\r\n    if (_support) {\r\n      proposal.forVotes += votes;\r\n    } else {\r\n      proposal.againstVotes += votes;\r\n    }\r\n\r\n    receipt.hasVoted = true;\r\n    receipt.support = _support;\r\n    receipt.votes = votes;\r\n  }\r\n\r\n  function withdraw() public {\r\n    require(block.timestamp > voteLock[msg.sender], \"Governance::withdraw: wait until voteLock expiration\");\r\n    votingToken.transfer(msg.sender, balanceOf[msg.sender]);\r\n    _burn(msg.sender, balanceOf[msg.sender]);\r\n  }\r\n\r\n  function _mint(address _account, uint _amount) internal {\r\n    balanceOf[_account] += _amount;\r\n  }\r\n\r\n  function _burn(address _account, uint _amount) internal {\r\n    balanceOf[_account] -= _amount;\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_votingToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposalId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executionPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"forVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"againstVotes\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"txHash\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"propose\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quorumVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"receipts\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"hasVoted\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"support\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"state\",\"outputs\":[{\"internalType\":\"enum Governance.ProposalState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposalId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_support\",\"type\":\"bool\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"voteLock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Governance", "CompilerVersion": "v0.8.1+commit.df193b15", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000006e36556b3ee5aa28def2a8ec3dae30ec2b208739", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0e66a4cae0251e53bbb4e865867b9f83d8540010b002fbdb1e72bf618353dc0b"}