{"SourceCode": "// Sources flattened with hardhat v2.3.0 https://hardhat.org\r\n\r\n// File contracts/5/openzeppelin/SafeMath.sol\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    function min256(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        return _a < _b ? _a : _b;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/5/openzeppelin/SignedSafeMath.sol\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\n/**\r\n * @title SignedSafeMath\r\n * @dev Signed math operations with safety checks that revert on error.\r\n */\r\nlibrary SignedSafeMath {\r\n    int256 constant private _INT256_MIN = -2**255;\r\n\r\n        /**\r\n     * @dev Returns the multiplication of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two signed integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0, \"SignedSafeMath: division by zero\");\r\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/5/openzeppelin/ReentrancyGuard.sol\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2\u03c0.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n    /// @dev Constant for unlocked guard state - non-zero to prevent extra gas costs.\r\n    /// See: https://github.com/OpenZeppelin/openzeppelin-solidity/issues/1056\r\n    uint256 internal constant REENTRANCY_GUARD_FREE = 1;\r\n\r\n    /// @dev Constant for locked guard state\r\n    uint256 internal constant REENTRANCY_GUARD_LOCKED = 2;\r\n\r\n    /**\r\n    * @dev We use a single lock for the whole contract.\r\n    */\r\n    uint256 internal reentrancyLock = REENTRANCY_GUARD_FREE;\r\n\r\n    /**\r\n    * @dev Prevents a contract from calling itself, directly or indirectly.\r\n    * If you mark a function `nonReentrant`, you should also\r\n    * mark it `external`. Calling one `nonReentrant` function from\r\n    * another is not supported. Instead, you can implement a\r\n    * `private` function doing the actual work, and an `external`\r\n    * wrapper marked as `nonReentrant`.\r\n    */\r\n    modifier nonReentrant() {\r\n        require(reentrancyLock == REENTRANCY_GUARD_FREE, \"nonReentrant\");\r\n        reentrancyLock = REENTRANCY_GUARD_LOCKED;\r\n        _;\r\n        reentrancyLock = REENTRANCY_GUARD_FREE;\r\n    }\r\n\r\n}\r\n\r\n\r\n// File contracts/5/openzeppelin/Context.sol\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/5/openzeppelin/Ownable.sol\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"unauthorized\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/5/openzeppelin/Address.sol\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following \r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n\r\n// File contracts/5/interfaces/IWbase.sol\r\n\r\n/**\r\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0.\r\n */\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\n\r\ninterface IWbase {\r\n    function deposit() external payable;\r\n    function withdraw(uint256 wad) external;\r\n}\r\n\r\n\r\n// File contracts/5/interfaces/IERC20.sol\r\n\r\n/**\r\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0.\r\n */\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\n\r\ncontract IERC20 {\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address _who) public view returns (uint256);\r\n    function transfer(address _to, uint256 _value) public returns (bool);\r\n    function allowance(address _owner, address _spender) public view returns (uint256);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\n    function approve(address _spender, uint256 _value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File contracts/5/interfaces/IWbaseERC20.sol\r\n\r\n/**\r\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0.\r\n */\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\n\r\ncontract IWbaseERC20 is IWbase, IERC20 {}\r\n\r\n\r\n// File contracts/5/openzeppelin/Pausable.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.5.17;\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\ncontract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor () public {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused(), \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused(), \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n\r\n// File contracts/5/connectors/loantoken/LoanTokenBase.sol\r\n\r\n/**\r\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0.\r\n */\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract LoanTokenBase is ReentrancyGuard, Ownable {\r\n\r\n    uint256 internal constant WEI_PRECISION = 10**18;\r\n    uint256 internal constant WEI_PERCENT_PRECISION = 10**20;\r\n\r\n    int256 internal constant sWEI_PRECISION = 10**18;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    address public loanTokenAddress;\r\n\r\n    uint256 public baseRate;\r\n    uint256 public rateMultiplier;\r\n    uint256 public lowUtilBaseRate;\r\n    uint256 public lowUtilRateMultiplier;\r\n\r\n    uint256 public targetLevel;\r\n    uint256 public kinkLevel;\r\n    uint256 public maxScaleRate;\r\n\r\n    uint256 internal _flTotalAssetSupply;\r\n    uint256 public checkpointSupply;\r\n    uint256 public initialPrice;\r\n\r\n    // uint88 for tight packing -> 8 + 88 + 160 = 256\r\n    uint88 internal lastSettleTime_;\r\n\r\n    mapping (uint256 => bytes32) public loanParamsIds; // mapping of keccak256(collateralToken, isTorqueLoan) to loanParamsId\r\n    mapping (address => uint256) internal checkpointPrices_; // price of token at last user checkpoint\r\n    \r\n    mapping(address => uint256) public transactionLimit;                                 // the maximum trading/borrowing/lending limit per token address\r\n                                                                                         // 0 -> no limit\r\n}\r\n\r\n\r\n// File contracts/5/connectors/loantoken/AdvancedTokenStorage.sol\r\n\r\n/**\r\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0.\r\n */\r\n\r\npragma solidity 0.5.17;\r\n\r\ncontract AdvancedTokenStorage is LoanTokenBase {\r\n    using SafeMath for uint256;\r\n\r\n    // topic: 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n\r\n    // topic: 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    // topic: 0xb4c03061fb5b7fed76389d5af8f2e0ddb09f8c70d1333abbb62582835e10accb\r\n    event Mint(\r\n        address indexed minter,\r\n        uint256 tokenAmount,\r\n        uint256 assetAmount,\r\n        uint256 price\r\n    );\r\n\r\n    // topic: 0x743033787f4738ff4d6a7225ce2bd0977ee5f86b91a902a58f5e4d0b297b4644\r\n    event Burn(\r\n        address indexed burner,\r\n        uint256 tokenAmount,\r\n        uint256 assetAmount,\r\n        uint256 price\r\n    );\r\n\r\n    mapping(address => uint256) internal balances;\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n    uint256 internal totalSupply_;\r\n\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return totalSupply_;\r\n    }\r\n\r\n    function balanceOf(\r\n        address _owner)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function allowance(\r\n        address _owner,\r\n        address _spender)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\n\r\n// File contracts/5/connectors/loantoken/AdvancedToken.sol\r\n\r\n/**\r\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0.\r\n */\r\n\r\npragma solidity 0.5.17;\r\n\r\ncontract AdvancedToken is AdvancedTokenStorage {\r\n    using SafeMath for uint256;\r\n\r\n    function approve(\r\n        address _spender,\r\n        uint256 _value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function _mint(\r\n        address _to,\r\n        uint256 _tokenAmount,\r\n        uint256 _assetAmount,\r\n        uint256 _price)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        require(_to != address(0), \"15\");\r\n\r\n        uint256 _balance = balances[_to]\r\n            .add(_tokenAmount);\r\n        balances[_to] = _balance;\r\n\r\n        totalSupply_ = totalSupply_\r\n            .add(_tokenAmount);\r\n\r\n        emit Mint(_to, _tokenAmount, _assetAmount, _price);\r\n        emit Transfer(address(0), _to, _tokenAmount);\r\n\r\n        return _balance;\r\n    }\r\n\r\n    function _burn(\r\n        address _who,\r\n        uint256 _tokenAmount,\r\n        uint256 _assetAmount,\r\n        uint256 _price)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        require(_tokenAmount <= balances[_who], \"16\");\r\n        // no need to require value <= totalSupply, since that would imply the\r\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n        uint256 _balance = balances[_who].sub(_tokenAmount);\r\n        if (_balance <= 10) { // we can't leave such small balance quantities\r\n            _tokenAmount = _tokenAmount.add(_balance);\r\n            _balance = 0;\r\n        }\r\n        balances[_who] = _balance;\r\n\r\n        totalSupply_ = totalSupply_.sub(_tokenAmount);\r\n\r\n        emit Burn(_who, _tokenAmount, _assetAmount, _price);\r\n        emit Transfer(_who, address(0), _tokenAmount);\r\n\r\n        return _balance;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/5/core/objects/LoanParamsStruct.sol\r\n\r\n/**\r\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0.\r\n */\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\ncontract LoanParamsStruct {\r\n    struct LoanParams {\r\n        bytes32 id;                 // id of loan params object\r\n        bool active;                // if false, this object has been disabled by the owner and can't be used for future loans\r\n        address owner;              // owner of this object\r\n        address loanToken;          // the token being loaned\r\n        address collateralToken;    // the required collateral token\r\n        uint256 minInitialMargin;   // the minimum allowed initial margin\r\n        uint256 maintenanceMargin;  // an unhealthy loan when current margin is at or below this value\r\n        uint256 maxLoanTerm;        // the maximum term for new loans (0 means there's no max term)\r\n    }\r\n}\r\n\r\n\r\n// File contracts/5/connectors/loantoken/interfaces/ProtocolSettingsLike.sol\r\n\r\n/**\r\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0.\r\n */\r\n\r\npragma solidity 0.5.17;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface ProtocolSettingsLike {\r\n    function setupLoanParams(\r\n        LoanParamsStruct.LoanParams[] calldata loanParamsList)\r\n        external\r\n        returns (bytes32[] memory loanParamsIdList);\r\n\r\n    function disableLoanParams(\r\n        bytes32[] calldata loanParamsIdList)\r\n        external;\r\n}\r\n\r\n\r\n// File contracts/5/connectors/loantoken/LoanTokenSettingsLowerAdmin.sol\r\n\r\n/**\r\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0.\r\n */\r\n\r\npragma solidity 0.5.17;\r\n\r\ncontract LoanTokenSettingsLowerAdmin is AdvancedToken {\r\n    using SafeMath for uint256;\r\n\r\n    // It is important to maintain the variables order so the delegate calls can access pfiContractAddress\r\n    address public pfiContractAddress;\r\n    \r\n    event SetTransactionLimits(address[] addresses, uint256[] limits);\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == address(this) ||\r\n            msg.sender == owner(), \"unauthorized\");\r\n        _;\r\n    }\r\n\r\n    function()\r\n        external\r\n    {\r\n        revert(\"LoanTokenSettingsLowerAdmin - fallback not allowed\");\r\n    }\r\n\r\n    function setupLoanParams(\r\n        LoanParamsStruct.LoanParams[] memory loanParamsList,\r\n        bool areTorqueLoans)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        bytes32[] memory loanParamsIdList;\r\n        address _loanTokenAddress = loanTokenAddress;\r\n\r\n        for (uint256 i = 0; i < loanParamsList.length; i++) {\r\n            loanParamsList[i].loanToken = _loanTokenAddress;\r\n            loanParamsList[i].maxLoanTerm = areTorqueLoans ? 0 : 1 days;\r\n        }\r\n\r\n        loanParamsIdList = ProtocolSettingsLike(pfiContractAddress).setupLoanParams(loanParamsList);\r\n        for (uint256 i = 0; i < loanParamsIdList.length; i++) {\r\n            loanParamsIds[uint256(keccak256(abi.encodePacked(\r\n                loanParamsList[i].collateralToken,\r\n                areTorqueLoans // isTorqueLoan\r\n            )))] = loanParamsIdList[i];\r\n        }\r\n    }\r\n\r\n\r\n    function disableLoanParams(\r\n        address[] calldata collateralTokens,\r\n        bool[] calldata isTorqueLoans)\r\n        external\r\n        onlyAdmin\r\n    {\r\n        require(collateralTokens.length == isTorqueLoans.length, \"count mismatch\");\r\n\r\n        bytes32[] memory loanParamsIdList = new bytes32[](collateralTokens.length);\r\n        for (uint256 i = 0; i < collateralTokens.length; i++) {\r\n            uint256 id = uint256(keccak256(abi.encodePacked(\r\n                collateralTokens[i],\r\n                isTorqueLoans[i]\r\n            )));\r\n            loanParamsIdList[i] = loanParamsIds[id];\r\n            delete loanParamsIds[id];\r\n        }\r\n\r\n        ProtocolSettingsLike(pfiContractAddress).disableLoanParams(loanParamsIdList);\r\n    }\r\n\r\n    // These params should be percentages represented like so: 5% = 5000000000000000000\r\n    // rateMultiplier + baseRate can't exceed 100%\r\n    function setDemandCurve(\r\n        uint256 _baseRate,\r\n        uint256 _rateMultiplier,\r\n        uint256 _lowUtilBaseRate,\r\n        uint256 _lowUtilRateMultiplier,\r\n        uint256 _targetLevel,\r\n        uint256 _kinkLevel,\r\n        uint256 _maxScaleRate)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(_rateMultiplier.add(_baseRate) <= WEI_PERCENT_PRECISION, \"curve params too high\");\r\n        require(_lowUtilRateMultiplier.add(_lowUtilBaseRate) <= WEI_PERCENT_PRECISION, \"curve params too high\");\r\n\r\n        require(_targetLevel <= WEI_PERCENT_PRECISION && _kinkLevel <= WEI_PERCENT_PRECISION, \"levels too high\");\r\n\r\n        baseRate = _baseRate;\r\n        rateMultiplier = _rateMultiplier;\r\n        lowUtilBaseRate = _lowUtilBaseRate;\r\n        lowUtilRateMultiplier = _lowUtilRateMultiplier;\r\n\r\n        targetLevel = _targetLevel; // 80 ether\r\n        kinkLevel = _kinkLevel; // 90 ether\r\n        maxScaleRate = _maxScaleRate; // 100 ether\r\n    }\r\n    \r\n    /**\r\n     * sets the transaction limit per token address\r\n     * @param addresses the token addresses\r\n     * @param limits the limit denominated in the currency of the token address\r\n     * */\r\n    function setTransactionLimits(\r\n        address[] memory addresses, \r\n        uint256[] memory limits) \r\n        public onlyOwner\r\n    {\r\n        require(addresses.length == limits.length, \"mismatched array lengths\");\r\n        for(uint i = 0; i < addresses.length; i++){\r\n            transactionLimit[addresses[i]] = limits[i];\r\n        }\r\n        emit SetTransactionLimits(addresses, limits);\r\n    }\r\n\r\n    function changeLoanTokenNameAndSymbol(string memory _name, string memory _symbol) public onlyAdmin {\r\n        name = _name;\r\n        symbol = _symbol;\r\n    }\r\n\r\n}\r\n\r\n\r\n// File contracts/5/connectors/loantoken/interfaces/ProtocolLike.sol\r\n\r\n/**\r\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0.\r\n */\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\ninterface ProtocolLike {\r\n    function borrowOrTradeFromPool(\r\n        bytes32 loanParamsId,\r\n        bytes32 loanId, // if 0, start a new loan\r\n        bool isTorqueLoan,\r\n        uint256 initialMargin,\r\n        address[4] calldata sentAddresses,\r\n            // lender: must match loan if loanId provided\r\n            // borrower: must match loan if loanId provided\r\n            // receiver: receiver of funds (address(0) assumes borrower address)\r\n            // manager: delegated manager of loan unless address(0)\r\n        uint256[5] calldata sentValues,\r\n            // newRate: new loan interest rate\r\n            // newPrincipal: new loan size (borrowAmount + any borrowed interest)\r\n            // torqueInterest: new amount of interest to escrow for Torque loan (determines initial loan length)\r\n            // loanTokenReceived: total loanToken deposit (amount not sent to borrower in the case of Torque loans)\r\n            // collateralTokenReceived: total collateralToken deposit\r\n        bytes calldata loanDataBytes)\r\n        external\r\n        payable\r\n        returns (uint256 newPrincipal, uint256 newCollateral);\r\n\r\n    function getTotalPrincipal(\r\n        address lender,\r\n        address loanToken)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function withdrawAccruedInterest(\r\n        address loanToken)\r\n        external;\r\n\r\n    function getLenderInterestData(\r\n        address lender,\r\n        address loanToken)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 interestPaid,\r\n            uint256 interestPaidDate,\r\n            uint256 interestOwedPerDay,\r\n            uint256 interestUnPaid,\r\n            uint256 interestFeePercent,\r\n            uint256 principalTotal);\r\n\r\n    function priceFeeds()\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function getEstimatedMarginExposure(\r\n        address loanToken,\r\n        address collateralToken,\r\n        uint256 loanTokenSent,\r\n        uint256 collateralTokenSent,\r\n        uint256 interestRate,\r\n        uint256 newPrincipal)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getRequiredCollateral(\r\n        address loanToken,\r\n        address collateralToken,\r\n        uint256 newPrincipal,\r\n        uint256 marginAmount,\r\n        bool isTorqueLoan)\r\n        external\r\n        view\r\n        returns (uint256 collateralAmountRequired);\r\n\r\n    function getBorrowAmount(\r\n        address loanToken,\r\n        address collateralToken,\r\n        uint256 collateralTokenAmount,\r\n        uint256 marginAmount,\r\n        bool isTorqueLoan)\r\n        external\r\n        view\r\n        returns (uint256 borrowAmount);\r\n\r\n    function isLoanPool(\r\n        address loanPool)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function lendingFeePercent()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getSwapExpectedReturn(\r\n        address sourceToken,\r\n        address destToken,\r\n        uint256 sourceTokenAmount) \r\n        external \r\n        view\r\n        returns(uint256);\r\n}\r\n\r\n\r\n// File contracts/5/connectors/loantoken/interfaces/FeedsLike.sol\r\n\r\n/**\r\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0.\r\n */\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\ninterface FeedsLike {\r\n    function queryRate(\r\n        address sourceTokenAddress,\r\n        address destTokenAddress)\r\n        external\r\n        view\r\n        returns (uint256 rate, uint256 precision);\r\n}\r\n\r\n\r\n// File contracts/5/connectors/loantoken/LoanTokenLogicStandard.sol\r\n\r\n/**\r\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0.\r\n */\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\ncontract LoanTokenLogicStandard is LoanTokenSettingsLowerAdmin, Pausable {\r\n    using SignedSafeMath for int256;\r\n\r\n    // It is important to maintain the variables order so the delegate calls can access pfiContractAddress and wbaseTokenAddress\r\n    address public wbaseTokenAddress;\r\n    address internal target_;\r\n\r\n    uint256 public constant VERSION = 5;\r\n    address internal constant arbitraryCaller = 0x000F400e6818158D541C3EBE45FE3AA0d47372FF;\r\n\r\n    function()\r\n        external\r\n    {\r\n        revert(\"loan token logic - fallback not allowed\");\r\n    }\r\n\r\n\r\n    /* Public functions */\r\n\r\n    function mint(\r\n        address receiver,\r\n        uint256 depositAmount)\r\n        external\r\n        nonReentrant\r\n        returns (uint256 mintAmount)\r\n    {\r\n        //temporary: limit transaction size\r\n        if(transactionLimit[loanTokenAddress] > 0)\r\n            require(depositAmount <= transactionLimit[loanTokenAddress]);\r\n            \r\n        return _mintToken(\r\n            receiver,\r\n            depositAmount\r\n        );\r\n    }\r\n\r\n    function burn(\r\n        address receiver,\r\n        uint256 burnAmount)\r\n        external\r\n        nonReentrant\r\n        returns (uint256 loanAmountPaid)\r\n    {\r\n        loanAmountPaid = _burnToken(\r\n            burnAmount\r\n        );\r\n\r\n        if (loanAmountPaid != 0) {\r\n            _safeTransfer(loanTokenAddress, receiver, loanAmountPaid, \"5\");\r\n        }\r\n    }\r\n    \r\n    \r\n    /*\r\n    flashBorrow is disabled for the MVP, but is going to be added later.\r\n    therefore, it needs to be revised\r\n    \r\n    function flashBorrow(\r\n        uint256 borrowAmount,\r\n        address borrower,\r\n        address target,\r\n        string calldata signature,\r\n        bytes calldata data)\r\n        external\r\n        payable\r\n        nonReentrant\r\n        pausable(msg.sig)\r\n        settlesInterest\r\n        returns (bytes memory)\r\n    {\r\n        require(borrowAmount != 0, \"38\");\r\n\r\n        _settleInterest();\r\n\r\n        // save before balances\r\n        uint256 beforeEtherBalance = address(this).balance.sub(msg.value);\r\n        uint256 beforeAssetsBalance = _underlyingBalance()\r\n            .add(totalAssetBorrow());\r\n\r\n        // lock totalAssetSupply for duration of flash loan\r\n        _flTotalAssetSupply = beforeAssetsBalance;\r\n\r\n        // transfer assets to calling contract\r\n        _safeTransfer(loanTokenAddress, borrower, borrowAmount, \"39\");\r\n\r\n        bytes memory callData;\r\n        if (bytes(signature).length == 0) {\r\n            callData = data;\r\n        } else {\r\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\r\n        }\r\n\r\n        // arbitrary call\r\n        (bool success, bytes memory returnData) = arbitraryCaller.call.value(msg.value)(\r\n            abi.encodeWithSelector(\r\n                0xde064e0d, // sendCall(address,bytes)\r\n                target,\r\n                callData\r\n            )\r\n        );\r\n        require(success, \"call failed\");\r\n\r\n        // unlock totalAssetSupply\r\n        _flTotalAssetSupply = 0;\r\n\r\n        // verifies return of flash loan\r\n        require(\r\n            address(this).balance >= beforeEtherBalance &&\r\n            _underlyingBalance()\r\n                .add(totalAssetBorrow()) >= beforeAssetsBalance,\r\n            \"40\"\r\n        );\r\n\r\n        return returnData;\r\n    }\r\n    */\r\n    \r\n    /**\r\n     * borrows funds from the pool. The underlying loan token may not be used as collateral.\r\n     * @param loanId the ID of the loan, 0 for a new loan \r\n     * @param withdrawAmount the amount to be withdrawn (actually borrowed)\r\n     * @param initialLoanDuration the duration of the loan in seconds. if the loan is not paid back until then, it'll need to be rolled over\r\n     * @param collateralTokenSent the amount of collateral token sent (150% of the withdrawn amount worth in collateral tokenns)\r\n     * @param collateralTokenAddress the address of the tokenn to be used as collateral. cannot be the loan token address\r\n     * @param borrower the one paying for the collateral\r\n     * @param receiver the one receiving the withdrawn amount\r\n     * */\r\n    function borrow(\r\n        bytes32 loanId,                 // 0 if new loan\r\n        uint256 withdrawAmount,\r\n        uint256 initialLoanDuration,    // duration in seconds\r\n        uint256 collateralTokenSent,    // if 0, loanId must be provided; any ETH sent must equal this value\r\n        address collateralTokenAddress, // if address(0), this means ETH and ETH must be sent with the call or loanId must be provided\r\n        address borrower,\r\n        address receiver,\r\n        bytes memory /*loanDataBytes*/) // arbitrary order data (for future use)\r\n        public\r\n        payable\r\n        nonReentrant                    //note: needs to be removed to allow flashloan use cases\r\n        whenNotPaused\r\n        returns (uint256, uint256) // returns new principal and new collateral added to loan\r\n    {\r\n        require(withdrawAmount != 0, \"6\");\r\n\r\n        //temporary: limit transaction size\r\n        if(transactionLimit[collateralTokenAddress] > 0)\r\n            require(collateralTokenSent <= transactionLimit[collateralTokenAddress]);\r\n\r\n        require(msg.value == 0 || msg.value == collateralTokenSent, \"7\");\r\n        require(collateralTokenSent != 0 || loanId != 0, \"8\");\r\n        require(collateralTokenAddress != address(0) || msg.value != 0 || loanId != 0, \"9\");\r\n\r\n        if (collateralTokenAddress == address(0)) {\r\n            collateralTokenAddress = wbaseTokenAddress;\r\n        }\r\n        require(collateralTokenAddress != loanTokenAddress, \"10\");\r\n\r\n        // ensures authorized use of existing loan\r\n        require(loanId == 0 || msg.sender == borrower, \"13\");\r\n\r\n        _settleInterest();\r\n\r\n        address[4] memory sentAddresses;\r\n        uint256[5] memory sentAmounts;\r\n\r\n        sentAddresses[0] = address(this); // lender\r\n        sentAddresses[1] = borrower;\r\n        sentAddresses[2] = receiver;\r\n        //sentAddresses[3] = address(0); // manager\r\n\r\n        sentAmounts[1] = withdrawAmount;\r\n\r\n        // interestRate, interestInitialAmount, borrowAmount (newBorrowAmount)\r\n        (sentAmounts[0], sentAmounts[2], sentAmounts[1]) = _getInterestRateAndBorrowAmount(\r\n            sentAmounts[1],\r\n            _totalAssetSupply(0), // interest is settled above\r\n            initialLoanDuration\r\n        );\r\n\r\n        //sentAmounts[3] = 0; // loanTokenSent\r\n        sentAmounts[4] = collateralTokenSent;\r\n\r\n        return _borrowOrTrade(\r\n            loanId,\r\n            withdrawAmount,\r\n            2 * 10**18, // leverageAmount (translates to 150% margin for a Torque loan)\r\n            collateralTokenAddress,\r\n            sentAddresses,\r\n            sentAmounts,\r\n            \"\" // loanDataBytes\r\n        );\r\n    }\r\n\r\n    // Called to borrow and immediately get into a positions\r\n    function marginTrade(\r\n        bytes32 loanId,                 // 0 if new loan\r\n        uint256 leverageAmount,         // expected in x * 10**18 where x is the actual leverage (2, 3, 4, or 5)\r\n        uint256 loanTokenSent,\r\n        uint256 collateralTokenSent,\r\n        address collateralTokenAddress,\r\n        address trader,\r\n        bytes memory loanDataBytes)     // arbitrary order data\r\n        public\r\n        payable\r\n        nonReentrant                    //note: needs to be removed to allow flashloan use cases\r\n        whenNotPaused\r\n        returns (uint256, uint256) // returns new principal and new collateral added to trade\r\n    {\r\n        // ensures authorized use of existing loan\r\n        require(loanId == 0 || msg.sender == trader, \"13\");\r\n \r\n        if (collateralTokenAddress == address(0)) {\r\n            collateralTokenAddress = wbaseTokenAddress;\r\n        }\r\n\r\n        require(collateralTokenAddress != loanTokenAddress, \"11\");\r\n        \r\n        //temporary: limit transaction size\r\n        if(transactionLimit[collateralTokenAddress] > 0)\r\n            require(collateralTokenSent <= transactionLimit[collateralTokenAddress]);\r\n        if(transactionLimit[loanTokenAddress] > 0)\r\n            require(loanTokenSent <= transactionLimit[loanTokenAddress]);\r\n        \r\n        //computes the worth of the total deposit in loan tokens.\r\n        //(loanTokenSent + convert(collateralTokenSent))\r\n        //no actual swap happening here.\r\n        uint256 totalDeposit = _totalDeposit(\r\n            collateralTokenAddress,\r\n            collateralTokenSent,\r\n            loanTokenSent\r\n        );\r\n        require(totalDeposit != 0, \"12\");\r\n\r\n        address[4] memory sentAddresses;\r\n        uint256[5] memory sentAmounts;\r\n\r\n        sentAddresses[0] = address(this); // lender\r\n        sentAddresses[1] = trader;\r\n        sentAddresses[2] = trader;\r\n        //sentAddresses[3] = address(0); // manager\r\n\r\n        //sentAmounts[0] = 0; // interestRate (found later)\r\n        sentAmounts[1] = totalDeposit; // total amount of deposit\r\n        //sentAmounts[2] = 0; // interestInitialAmount (interest is calculated based on fixed-term loan)\r\n        sentAmounts[3] = loanTokenSent;\r\n        sentAmounts[4] = collateralTokenSent;\r\n\r\n        _settleInterest();\r\n\r\n        (sentAmounts[1], sentAmounts[0]) = _getMarginBorrowAmountAndRate( // borrowAmount, interestRate\r\n            leverageAmount,\r\n            sentAmounts[1] // depositAmount\r\n        );\r\n\r\n        return _borrowOrTrade(\r\n            loanId,\r\n            0, // withdrawAmount\r\n            leverageAmount,\r\n            collateralTokenAddress,\r\n            sentAddresses,\r\n            sentAmounts,\r\n            loanDataBytes\r\n        );\r\n    }\r\n\r\n    function transfer(\r\n        address _to,\r\n        uint256 _value)\r\n        external\r\n        returns (bool)\r\n    {\r\n        return _internalTransferFrom(\r\n            msg.sender,\r\n            _to,\r\n            _value,\r\n            uint256(-1)\r\n        );\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value)\r\n        external\r\n        returns (bool)\r\n    {\r\n        return _internalTransferFrom(\r\n            _from,\r\n            _to,\r\n            _value,\r\n            ProtocolLike(pfiContractAddress).isLoanPool(msg.sender) ?\r\n                uint256(-1) :\r\n                allowed[_from][msg.sender]\r\n        );\r\n    }\r\n\r\n    function _internalTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _allowanceAmount)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        if (_allowanceAmount != uint256(-1)) {\r\n            require(_value <= _allowanceAmount, \"14\");\r\n            allowed[_from][msg.sender] = _allowanceAmount.sub(_value);\r\n        }\r\n\r\n        uint256 _balancesFrom = balances[_from];\r\n        require(_value <= _balancesFrom &&\r\n            _to != address(0),\r\n            \"14\"\r\n        );\r\n        \r\n        \r\n        uint256 _balancesFromNew = _balancesFrom\r\n            .sub(_value);\r\n        balances[_from] = _balancesFromNew;\r\n        \r\n        uint256 _balancesTo = balances[_to];\r\n        uint256 _balancesToNew = _balancesTo\r\n            .add(_value);\r\n        balances[_to] = _balancesToNew;\r\n\r\n        // handle checkpoint update\r\n        uint256 _currentPrice = tokenPrice();\r\n\r\n        _updateCheckpoints(\r\n            _from,\r\n            _balancesFrom,\r\n            _balancesFromNew,\r\n            _currentPrice\r\n        );\r\n        _updateCheckpoints(\r\n            _to,\r\n            _balancesTo,\r\n            _balancesToNew,\r\n            _currentPrice\r\n        );\r\n\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    \r\n    /**\r\n     * @dev updates the user's checkpoint price and profit so far.\r\n     * @param _user the user address\r\n     * @param _oldBalance the user's previous balance\r\n     * @param _newBalance the user's updated balance\r\n     * @param _currentPrice the current iToken price\r\n     * */\r\n    function _updateCheckpoints(\r\n        address _user,\r\n        uint256 _oldBalance,\r\n        uint256 _newBalance,\r\n        uint256 _currentPrice)\r\n        internal\r\n    {\r\n        // keccak256(\"iToken_ProfitSoFar\")\r\n        bytes32 slot = keccak256(\r\n            abi.encodePacked(_user, uint256(0x37aa2b7d583612f016e4a4de4292cb015139b3d7762663d06a53964912ea2fb6))\r\n        );\r\n\r\n        uint256 _currentProfit;\r\n        if (_oldBalance != 0 && _newBalance != 0) {\r\n            _currentProfit = _profitOf(\r\n                slot,\r\n                _oldBalance,\r\n                _currentPrice,\r\n                checkpointPrices_[_user]\r\n            );\r\n        } else if (_newBalance == 0) {\r\n            _currentPrice = 0;\r\n        }\r\n\r\n        assembly {\r\n            sstore(slot, _currentProfit)\r\n        }\r\n\r\n        checkpointPrices_[_user] = _currentPrice;\r\n\r\n    }\r\n\r\n    /* Public View functions */\r\n\r\n    function profitOf(\r\n        address user)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // keccak256(\"iToken_ProfitSoFar\")\r\n        bytes32 slot = keccak256(\r\n            abi.encodePacked(user, uint256(0x37aa2b7d583612f016e4a4de4292cb015139b3d7762663d06a53964912ea2fb6))\r\n        );\r\n\r\n        return _profitOf(\r\n            slot,\r\n            balances[user],\r\n            tokenPrice(),\r\n            checkpointPrices_[user]\r\n        );\r\n    }\r\n\r\n    function _profitOf(\r\n        bytes32 slot,\r\n        uint256 _balance,\r\n        uint256 _currentPrice,\r\n        uint256 _checkpointPrice)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (_checkpointPrice == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 profitSoFar;\r\n        uint256 profitDiff;\r\n\r\n        assembly {\r\n            profitSoFar := sload(slot)\r\n        }\r\n\r\n        if (_currentPrice > _checkpointPrice) {\r\n            profitDiff = _balance\r\n                .mul(_currentPrice - _checkpointPrice)\r\n                .div(10**18);\r\n            profitSoFar = profitSoFar\r\n                .add(profitDiff);\r\n        } else {\r\n            profitDiff = _balance\r\n                .mul(_checkpointPrice - _currentPrice)\r\n                .div(10**18);\r\n            if (profitSoFar > profitDiff) {\r\n                profitSoFar = profitSoFar - profitDiff;\r\n            } else {\r\n                profitSoFar = 0;\r\n            }\r\n        }\r\n\r\n        return profitSoFar;\r\n    }\r\n\r\n    function tokenPrice()\r\n        public\r\n        view\r\n        returns (uint256 price)\r\n    {\r\n        uint256 interestUnPaid;\r\n        if (lastSettleTime_ != uint88(block.timestamp)) {\r\n            (,interestUnPaid) = _getAllInterest();\r\n        }\r\n\r\n        return _tokenPrice(_totalAssetSupply(interestUnPaid));\r\n    }\r\n\r\n    function checkpointPrice(\r\n        address _user)\r\n        public\r\n        view\r\n        returns (uint256 price)\r\n    {\r\n        return checkpointPrices_[_user];\r\n    }\r\n\r\n    function marketLiquidity()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 totalSupply = _totalAssetSupply(0);\r\n        uint256 totalBorrow = totalAssetBorrow();\r\n        if (totalSupply > totalBorrow) {\r\n            return totalSupply.sub(totalBorrow);\r\n        }\r\n    }\r\n\r\n    function avgBorrowInterestRate()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _avgBorrowInterestRate(totalAssetBorrow());\r\n    }\r\n\r\n    // the minimum rate the next base protocol borrower will receive for variable-rate loans\r\n    function borrowInterestRate()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _nextBorrowInterestRate(0);\r\n    }\r\n\r\n    function nextBorrowInterestRate(\r\n        uint256 borrowAmount)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _nextBorrowInterestRate(borrowAmount);\r\n    }\r\n\r\n    // interest that lenders are currently receiving when supplying to the pool\r\n    function supplyInterestRate()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return totalSupplyInterestRate(_totalAssetSupply(0));\r\n    }\r\n\r\n    function nextSupplyInterestRate(\r\n        uint256 supplyAmount)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return totalSupplyInterestRate(_totalAssetSupply(0).add(supplyAmount));\r\n    }\r\n\r\n    function totalSupplyInterestRate(\r\n        uint256 assetSupply)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 assetBorrow = totalAssetBorrow();\r\n        if (assetBorrow != 0) {\r\n            return _supplyInterestRate(\r\n                assetBorrow,\r\n                assetSupply\r\n            );\r\n        }\r\n    }\r\n\r\n    function totalAssetBorrow()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return ProtocolLike(pfiContractAddress).getTotalPrincipal(\r\n            address(this),\r\n            loanTokenAddress\r\n        );\r\n    }\r\n\r\n    function totalAssetSupply()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 interestUnPaid;\r\n        if (lastSettleTime_ != uint88(block.timestamp)) {\r\n            (,interestUnPaid) = _getAllInterest();\r\n        }\r\n\r\n        return _totalAssetSupply(interestUnPaid);\r\n    }\r\n    \r\n    /**\r\n     * @notice computes the maximum deposit amount under current market conditions\r\n     * @dev maxEscrowAmount = liquidity * (100 - interestForDuration) / 100\r\n     * @param leverageAmount the chosen leverage with 18 decimals\r\n     * */\r\n    function getMaxEscrowAmount(\r\n        uint256 leverageAmount)\r\n        public\r\n        view\r\n        returns (uint256 maxEscrowAmount)\r\n    {\r\n        //mathematical imperfection. depending on liquidity we might be able to borrow more if utilization is below the kink level\r\n        uint256 interestForDuration = maxScaleRate.mul(28).div(365);\r\n        uint256 factor = uint256(10**20).sub(interestForDuration);\r\n        uint256 maxLoanSize = marketLiquidity().mul(factor).div(10**20);\r\n        maxEscrowAmount = maxLoanSize.mul(10**18).div(leverageAmount);\r\n    }\r\n\r\n    // returns the user's balance of underlying token\r\n    function assetBalanceOf(\r\n        address _owner)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return balanceOf(_owner)\r\n            .mul(tokenPrice())\r\n            .div(10**18);\r\n    }\r\n\r\n    function getEstimatedMarginDetails(\r\n        uint256 leverageAmount,\r\n        uint256 loanTokenSent,\r\n        uint256 collateralTokenSent,\r\n        address collateralTokenAddress)     // address(0) means ETH\r\n        public\r\n        view\r\n        returns (uint256 principal, uint256 collateral, uint256 interestRate)\r\n    {\r\n        if (collateralTokenAddress == address(0)) {\r\n            collateralTokenAddress = wbaseTokenAddress;\r\n        }\r\n\r\n        uint256 totalDeposit = _totalDeposit(\r\n            collateralTokenAddress,\r\n            collateralTokenSent,\r\n            loanTokenSent\r\n        );\r\n\r\n        (principal, interestRate) = _getMarginBorrowAmountAndRate(\r\n            leverageAmount,\r\n            totalDeposit\r\n        );\r\n        if (principal > _underlyingBalance()) {\r\n            return (0, 0, 0);\r\n        }\r\n\r\n        loanTokenSent = loanTokenSent\r\n            .add(principal);\r\n\r\n        collateral = ProtocolLike(pfiContractAddress).getEstimatedMarginExposure(\r\n            loanTokenAddress,\r\n            collateralTokenAddress,\r\n            loanTokenSent,\r\n            collateralTokenSent,\r\n            interestRate,\r\n            principal\r\n        );\r\n    }\r\n\r\n    function getDepositAmountForBorrow(\r\n        uint256 borrowAmount,\r\n        uint256 initialLoanDuration,        // duration in seconds\r\n        address collateralTokenAddress)     // address(0) means ETH\r\n        public\r\n        view\r\n        returns (uint256 depositAmount)\r\n    {\r\n        if (borrowAmount != 0) {\r\n            (,,uint256 newBorrowAmount) = _getInterestRateAndBorrowAmount(\r\n                borrowAmount,\r\n                totalAssetSupply(),\r\n                initialLoanDuration\r\n            );\r\n\r\n            if (newBorrowAmount <= _underlyingBalance()) {\r\n                return ProtocolLike(pfiContractAddress).getRequiredCollateral(\r\n                    loanTokenAddress,\r\n                    collateralTokenAddress != address(0) ? collateralTokenAddress : wbaseTokenAddress,\r\n                    newBorrowAmount,\r\n                    50 * 10**18, // initialMargin\r\n                    true // isTorqueLoan\r\n                ).add(10); // some dust to compensate for rounding errors\r\n            }\r\n        }\r\n    }\r\n\r\n    function getBorrowAmountForDeposit(\r\n        uint256 depositAmount,\r\n        uint256 initialLoanDuration,        // duration in seconds\r\n        address collateralTokenAddress)     // address(0) means ETH\r\n        public\r\n        view\r\n        returns (uint256 borrowAmount)\r\n    {\r\n        if (depositAmount != 0) {\r\n            borrowAmount = ProtocolLike(pfiContractAddress).getBorrowAmount(\r\n                loanTokenAddress,\r\n                collateralTokenAddress != address(0) ? collateralTokenAddress : wbaseTokenAddress,\r\n                depositAmount,\r\n                50 * 10**18, // initialMargin,\r\n                true // isTorqueLoan\r\n            );\r\n\r\n            (,,borrowAmount) = _getInterestRateAndBorrowAmount(\r\n                borrowAmount,\r\n                totalAssetSupply(),\r\n                initialLoanDuration\r\n            );\r\n\r\n            if (borrowAmount > _underlyingBalance()) {\r\n                borrowAmount = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    /* Internal functions */\r\n\r\n    function _mintToken(\r\n        address receiver,\r\n        uint256 depositAmount)\r\n        internal\r\n        returns (uint256 mintAmount)\r\n    {\r\n        require (depositAmount != 0, \"17\");\r\n\r\n        _settleInterest();\r\n\r\n        uint256 currentPrice = _tokenPrice(_totalAssetSupply(0));\r\n        mintAmount = depositAmount\r\n            .mul(10**18)\r\n            .div(currentPrice);\r\n\r\n        if (msg.value == 0) {\r\n            _safeTransferFrom(loanTokenAddress, msg.sender, address(this), depositAmount, \"18\");\r\n        } else {\r\n            IWbase(wbaseTokenAddress).deposit.value(depositAmount)();\r\n        }\r\n\r\n        uint256 oldBalance = balances[receiver];\r\n        _updateCheckpoints(\r\n            receiver,\r\n            oldBalance,\r\n            _mint(receiver, mintAmount, depositAmount, currentPrice), // newBalance\r\n            currentPrice\r\n        );\r\n    }\r\n\r\n    function _burnToken(\r\n        uint256 burnAmount)\r\n        internal\r\n        returns (uint256 loanAmountPaid)\r\n    {\r\n        require(burnAmount != 0, \"19\");\r\n\r\n        if (burnAmount > balanceOf(msg.sender)) {\r\n            burnAmount = balanceOf(msg.sender);\r\n        }\r\n\r\n        _settleInterest();\r\n\r\n        uint256 currentPrice = _tokenPrice(_totalAssetSupply(0));\r\n\r\n        uint256 loanAmountOwed = burnAmount\r\n            .mul(currentPrice)\r\n            .div(10**18);\r\n        uint256 loanAmountAvailableInContract = _underlyingBalance();\r\n\r\n        loanAmountPaid = loanAmountOwed;\r\n        require(loanAmountPaid <= loanAmountAvailableInContract, \"37\");\r\n\r\n        uint256 oldBalance = balances[msg.sender];\r\n        \r\n        //this function does not only update the checkpoints but also the current profit of the user\r\n        _updateCheckpoints(\r\n            msg.sender,\r\n            oldBalance,\r\n            _burn(msg.sender, burnAmount, loanAmountPaid, currentPrice), // newBalance\r\n            currentPrice\r\n        );\r\n    }\r\n\r\n    function _settleInterest()\r\n        internal\r\n    {\r\n        uint88 ts = uint88(block.timestamp);\r\n        if (lastSettleTime_ != ts) {\r\n            ProtocolLike(pfiContractAddress).withdrawAccruedInterest(\r\n                loanTokenAddress\r\n            );\r\n\r\n            lastSettleTime_ = ts;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev computes what the deposit is worth in loan tokens using the swap rate \r\n     *      used for loan size computation\r\n     * @param collateralTokenAddress the address of the collateral token\r\n     * @param collateralTokenSent the number of collateral tokens provided the user\r\n     * @param loanTokenSent the number of loan tokens provided by the user\r\n     * @return the value of the deposit in loan tokens\r\n     * */\r\n    function _totalDeposit(\r\n        address collateralTokenAddress,\r\n        uint256 collateralTokenSent,\r\n        uint256 loanTokenSent)\r\n        internal\r\n        view\r\n        returns (uint256 totalDeposit)\r\n    {\r\n        totalDeposit = loanTokenSent;\r\n\r\n        if (collateralTokenSent != 0) {\r\n            //get the oracle rate from collateral -> loan\r\n            (uint256 collateralToLoanRate, uint256 collateralToLoanPrecision) = FeedsLike(ProtocolLike(pfiContractAddress).priceFeeds()).queryRate(\r\n                collateralTokenAddress,\r\n                loanTokenAddress\r\n            );\r\n            require((collateralToLoanRate != 0) && (collateralToLoanPrecision != 0), \"invalid exchange rate for the collateral token\");\r\n            \r\n            //compute the loan token amount with the oracle rate\r\n            uint256 loanTokenAmount = collateralTokenSent\r\n                .mul(collateralToLoanRate)\r\n                .div(collateralToLoanPrecision\r\n            );\r\n            \r\n            //see how many collateralTokens we would get if exchanging this amount of loan tokens to collateral tokens\r\n            uint256 collateralTokenAmount = ProtocolLike(pfiContractAddress).getSwapExpectedReturn(\r\n                loanTokenAddress,\r\n                collateralTokenAddress,\r\n                loanTokenAmount\r\n            );\r\n            \r\n            //probably not the same due to the price difference\r\n            if (collateralTokenAmount != collateralTokenSent) {\r\n                //scale the loan token amount accordingly, so we'll get the expected position size in the end\r\n                loanTokenAmount = loanTokenAmount\r\n                    .mul(collateralTokenAmount)\r\n                    .div(collateralTokenSent\r\n                );\r\n            }\r\n\r\n            totalDeposit = loanTokenAmount.add(totalDeposit);\r\n\r\n        }            \r\n    }\r\n\r\n    function _getInterestRateAndBorrowAmount(\r\n        uint256 borrowAmount,\r\n        uint256 assetSupply,\r\n        uint256 initialLoanDuration) // duration in seconds\r\n        internal\r\n        view\r\n        returns (uint256 interestRate, uint256 interestInitialAmount, uint256 newBorrowAmount)\r\n    {\r\n        interestRate = _nextBorrowInterestRate2(\r\n            borrowAmount,\r\n            assetSupply\r\n        );\r\n\r\n        // newBorrowAmount = borrowAmount * 10^18 / (10^18 - interestRate * 7884000 * 10^18 / 31536000 / 10^20)\r\n        newBorrowAmount = borrowAmount\r\n            .mul(10**18)\r\n            .div(\r\n                SafeMath.sub(10**18,\r\n                    interestRate\r\n                        .mul(initialLoanDuration)\r\n                        .mul(10**18)\r\n                        .div(31536000 * 10**20) // 365 * 86400 * 10**20\r\n                )\r\n            );\r\n\r\n        interestInitialAmount = newBorrowAmount\r\n            .sub(borrowAmount);\r\n    }\r\n\r\n    // returns newPrincipal\r\n    function _borrowOrTrade(\r\n        bytes32 loanId,\r\n        uint256 withdrawAmount,\r\n        uint256 leverageAmount,\r\n        address collateralTokenAddress,\r\n        address[4] memory sentAddresses,\r\n        uint256[5] memory sentAmounts,\r\n        bytes memory loanDataBytes)\r\n        internal\r\n        whenNotPaused\r\n        returns (uint256, uint256)\r\n    {\r\n        require (sentAmounts[1] <= _underlyingBalance() && // newPrincipal (borrowed amount + fees)\r\n            sentAddresses[1] != address(0), // borrower\r\n            \"24\"\r\n        );\r\n\r\n\t    if (sentAddresses[2] == address(0)) {\r\n            sentAddresses[2] = sentAddresses[1]; // receiver = borrower\r\n        }\r\n\r\n        // handle transfers prior to adding newPrincipal to loanTokenSent\r\n        uint256 msgValue = _verifyTransfers(\r\n            collateralTokenAddress,\r\n            sentAddresses,\r\n            sentAmounts,\r\n            withdrawAmount\r\n        );\r\n\r\n        // adding the loan token portion from the lender to loanTokenSent\r\n        // (add the loan to the loan tokens sent from the user)\r\n        sentAmounts[3] = sentAmounts[3]\r\n            .add(sentAmounts[1]); // newPrincipal\r\n\r\n        if (withdrawAmount != 0) {\r\n            // withdrawAmount already sent to the borrower, so we aren't sending it to the protocol\r\n            sentAmounts[3] = sentAmounts[3]\r\n                .sub(withdrawAmount);\r\n        }\r\n\r\n        bytes32 loanParamsId = loanParamsIds[uint256(keccak256(abi.encodePacked(\r\n            collateralTokenAddress,\r\n            withdrawAmount != 0 ? // isTorqueLoan\r\n                true :\r\n                false\r\n        )))];\r\n\r\n        // converting to initialMargin\r\n        leverageAmount = SafeMath.div(10**38, leverageAmount);\r\n        (sentAmounts[1], sentAmounts[4]) = ProtocolLike(pfiContractAddress).borrowOrTradeFromPool.value(msgValue)( // newPrincipal, newCollateral\r\n            loanParamsId,\r\n            loanId,\r\n            withdrawAmount != 0 ? // isTorqueLoan\r\n                true :\r\n                false,\r\n            leverageAmount, // initialMargin\r\n            sentAddresses,\r\n            sentAmounts,\r\n            loanDataBytes\r\n        );\r\n        require (sentAmounts[1] != 0, \"25\");\r\n\r\n        return (sentAmounts[1], sentAmounts[4]); // newPrincipal, newCollateral\r\n    }\r\n\r\n    // sentAddresses[0]: lender\r\n    // sentAddresses[1]: borrower\r\n    // sentAddresses[2]: receiver\r\n    // sentAddresses[3]: manager\r\n    // sentAmounts[0]: interestRate\r\n    // sentAmounts[1]: newPrincipal\r\n    // sentAmounts[2]: interestInitialAmount\r\n    // sentAmounts[3]: loanTokenSent\r\n    // sentAmounts[4]: collateralTokenSent\r\n    function _verifyTransfers(\r\n        address collateralTokenAddress,\r\n        address[4] memory sentAddresses,\r\n        uint256[5] memory sentAmounts,\r\n        uint256 withdrawalAmount)\r\n        internal\r\n        returns (uint256 msgValue)\r\n    {\r\n        address _wbaseToken = wbaseTokenAddress;\r\n        address _loanTokenAddress = loanTokenAddress;\r\n        address receiver = sentAddresses[2];\r\n        uint256 newPrincipal = sentAmounts[1];\r\n        uint256 loanTokenSent = sentAmounts[3];\r\n        uint256 collateralTokenSent = sentAmounts[4];\r\n\r\n        require(_loanTokenAddress != collateralTokenAddress, \"26\");\r\n\r\n        msgValue = msg.value;\r\n\r\n        if (withdrawalAmount != 0) { // withdrawOnOpen == true\r\n            _safeTransfer(_loanTokenAddress, receiver, withdrawalAmount, \"\");\r\n            if (newPrincipal > withdrawalAmount) {\r\n                _safeTransfer(_loanTokenAddress, pfiContractAddress, newPrincipal - withdrawalAmount, \"\");\r\n            }\r\n        } else {\r\n            _safeTransfer(_loanTokenAddress, pfiContractAddress, newPrincipal, \"27\");\r\n        }\r\n        //this is a critical piece of code!\r\n        //wEth are supposed to be held by the contract itself, while other tokens are being transfered from the sender directly\r\n        if (collateralTokenSent != 0) {\r\n            if (collateralTokenAddress == _wbaseToken && msgValue != 0 && msgValue >= collateralTokenSent) {\r\n                IWbase(_wbaseToken).deposit.value(collateralTokenSent)();\r\n                _safeTransfer(collateralTokenAddress, pfiContractAddress, collateralTokenSent, \"28-a\");\r\n                msgValue -= collateralTokenSent;\r\n            } else {\r\n                _safeTransferFrom(collateralTokenAddress, msg.sender, pfiContractAddress, collateralTokenSent, \"28-b\");\r\n            }\r\n        }\r\n\r\n        if (loanTokenSent != 0) {\r\n            _safeTransferFrom(_loanTokenAddress, msg.sender, pfiContractAddress, loanTokenSent, \"29\");\r\n        }\r\n    }\r\n\r\n    function _safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 amount,\r\n        string memory errorMsg)\r\n        internal\r\n    {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(IERC20(token).transfer.selector, to, amount),\r\n            errorMsg\r\n        );\r\n    }\r\n\r\n    function _safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        string memory errorMsg)\r\n        internal\r\n    {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(IERC20(token).transferFrom.selector, from, to, amount),\r\n            errorMsg\r\n        );\r\n    }\r\n\r\n    function _callOptionalReturn(\r\n        address token,\r\n        bytes memory data,\r\n        string memory errorMsg)\r\n        internal\r\n    {\r\n        (bool success, bytes memory returndata) = token.call(data);\r\n        require(success, errorMsg);\r\n\r\n        if (returndata.length != 0) {\r\n            require(abi.decode(returndata, (bool)), errorMsg);\r\n        }\r\n    }\r\n\r\n    function _underlyingBalance()\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return IERC20(loanTokenAddress).balanceOf(address(this));\r\n    }\r\n\r\n    /* Internal View functions */\r\n\r\n    function _tokenPrice(\r\n        uint256 assetSupply)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 totalTokenSupply = totalSupply_;\r\n\r\n        return totalTokenSupply != 0 ?\r\n            assetSupply\r\n                .mul(10**18)\r\n                .div(totalTokenSupply) : initialPrice;\r\n    }\r\n\r\n    function _avgBorrowInterestRate(\r\n        uint256 assetBorrow)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (assetBorrow != 0) {\r\n            (uint256 interestOwedPerDay,) = _getAllInterest();\r\n            return interestOwedPerDay\r\n                .mul(10**20)\r\n                .div(assetBorrow)\r\n                .mul(365);\r\n        }\r\n    }\r\n\r\n    // next supply interest adjustment\r\n    function _supplyInterestRate(\r\n        uint256 assetBorrow,\r\n        uint256 assetSupply)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (assetBorrow != 0 && assetSupply >= assetBorrow) {\r\n            return _avgBorrowInterestRate(assetBorrow)\r\n                .mul(_utilizationRate(assetBorrow, assetSupply))\r\n                .mul(SafeMath.sub(10**20, ProtocolLike(pfiContractAddress).lendingFeePercent()))\r\n                .div(10**40);\r\n        }\r\n    }\r\n\r\n    function _nextBorrowInterestRate(\r\n        uint256 borrowAmount)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 interestUnPaid;\r\n        if (borrowAmount != 0) {\r\n            if (lastSettleTime_ != uint88(block.timestamp)) {\r\n                (,interestUnPaid) = _getAllInterest();\r\n            }\r\n\r\n            uint256 balance = _underlyingBalance()\r\n                .add(interestUnPaid);\r\n            if (borrowAmount > balance) {\r\n                borrowAmount = balance;\r\n            }\r\n        }\r\n\r\n        return _nextBorrowInterestRate2(\r\n            borrowAmount,\r\n            _totalAssetSupply(interestUnPaid)\r\n        );\r\n    }\r\n\r\n    function _nextBorrowInterestRate2(\r\n        uint256 newBorrowAmount,\r\n        uint256 assetSupply)\r\n        internal\r\n        view\r\n        returns (uint256 nextRate)\r\n    {\r\n        uint256 utilRate = _utilizationRate(\r\n            totalAssetBorrow().add(newBorrowAmount),\r\n            assetSupply\r\n        );\r\n\r\n        uint256 thisMinRate;\r\n        uint256 thisMaxRate;\r\n        uint256 thisBaseRate = baseRate;\r\n        uint256 thisRateMultiplier = rateMultiplier;\r\n        uint256 thisTargetLevel = targetLevel;\r\n        uint256 thisKinkLevel = kinkLevel;\r\n        uint256 thisMaxScaleRate = maxScaleRate;\r\n\r\n        if (utilRate < thisTargetLevel) {\r\n            // target targetLevel utilization when utilization is under targetLevel\r\n            utilRate = thisTargetLevel;\r\n        }\r\n\r\n        if (utilRate > thisKinkLevel) {\r\n            // scale rate proportionally up to 100%\r\n            uint256 thisMaxRange = WEI_PERCENT_PRECISION - thisKinkLevel; // will not overflow\r\n\r\n            utilRate -= thisKinkLevel;\r\n            if (utilRate > thisMaxRange)\r\n                utilRate = thisMaxRange;\r\n\r\n            thisMaxRate = thisRateMultiplier\r\n                .add(thisBaseRate)\r\n                .mul(thisKinkLevel)\r\n                .div(WEI_PERCENT_PRECISION);\r\n\r\n            nextRate = utilRate\r\n                .mul(SafeMath.sub(thisMaxScaleRate, thisMaxRate))\r\n                .div(thisMaxRange)\r\n                .add(thisMaxRate);\r\n        } else {\r\n            nextRate = utilRate\r\n                .mul(thisRateMultiplier)\r\n                .div(WEI_PERCENT_PRECISION)\r\n                .add(thisBaseRate);\r\n\r\n            thisMinRate = thisBaseRate;\r\n            thisMaxRate = thisRateMultiplier\r\n                .add(thisBaseRate);\r\n\r\n            if (nextRate < thisMinRate)\r\n                nextRate = thisMinRate;\r\n            else if (nextRate > thisMaxRate)\r\n                nextRate = thisMaxRate;\r\n        }\r\n    }\r\n\r\n    function _getAllInterest()\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 interestOwedPerDay,\r\n            uint256 interestUnPaid)\r\n    {\r\n        // interestPaid, interestPaidDate, interestOwedPerDay, interestUnPaid, interestFeePercent, principalTotal\r\n        uint256 interestFeePercent;\r\n        (,,interestOwedPerDay,interestUnPaid,interestFeePercent,) = ProtocolLike(pfiContractAddress).getLenderInterestData(\r\n            address(this),\r\n            loanTokenAddress\r\n        );\r\n\r\n        interestUnPaid = interestUnPaid\r\n            .mul(SafeMath.sub(10**20, interestFeePercent))\r\n            .div(10**20);\r\n    }\r\n    \r\n    /**\r\n     * @notice computes the loan size and interest rate\r\n     * @param leverageAmount the leverage with 18 decimals\r\n     * @param depositAmount the amount the user deposited in underlying loan tokens\r\n     * */\r\n    function _getMarginBorrowAmountAndRate(\r\n        uint256 leverageAmount,\r\n        uint256 depositAmount)\r\n        internal\r\n        view\r\n        returns (uint256 borrowAmount, uint256 interestRate)\r\n    {\r\n        uint256 loanSizeBeforeInterest = depositAmount.mul(leverageAmount).div(10**18);\r\n        //mathematical imperfection. we calculate the interest rate based on the loanSizeBeforeInterest, but \r\n        //the actual borrowed amount will be bigger.\r\n        interestRate = _nextBorrowInterestRate2(loanSizeBeforeInterest, _totalAssetSupply(0));\r\n        // assumes that loan, collateral, and interest token are the same\r\n        borrowAmount = _adjustLoanSize(interestRate, 1 days, loanSizeBeforeInterest);\r\n    }\r\n\r\n    function _totalAssetSupply(\r\n        uint256 interestUnPaid)\r\n        internal\r\n        view\r\n        returns (uint256 assetSupply)\r\n    {\r\n        if (totalSupply_ != 0) {\r\n            uint256 assetsBalance = _flTotalAssetSupply; // temporary locked totalAssetSupply during a flash loan transaction\r\n            if (assetsBalance == 0) {\r\n                assetsBalance = _underlyingBalance()\r\n                    .add(totalAssetBorrow());\r\n            }\r\n\r\n            return assetsBalance\r\n                .add(interestUnPaid);\r\n        }\r\n    }\r\n    \r\n    function toggleFunctionPause(bool isPaused) public onlyAdmin {\r\n        if(isPaused) {\r\n            _pause();\r\n        } else {\r\n            _unpause();\r\n        }\r\n    }\r\n    /**\r\n     * used to read externally from the smart contract to see if a function is paused\r\n     * returns a bool\r\n     * */\r\n    function checkPause() public view returns (bool isPaused){\r\n       isPaused = paused(); \r\n    }\r\n    \r\n    /**\r\n     * @notice adjusts the loan size to make sure the expected exposure remains after prepaying the interest\r\n     * @dev loanSizeWithInterest = loanSizeBeforeInterest * 100 / (100 - interestForDuration)\r\n     * @param interestRate the interest rate to pay on the position\r\n     * @param maxDuration the maximum duration of the position (until rollover)\r\n     * @param loanSizeBeforeInterest the loan size before interest is added \r\n     * */\r\n    function _adjustLoanSize(\r\n        uint256 interestRate,\r\n        uint256 maxDuration,\r\n        uint256 loanSizeBeforeInterest)\r\n        internal\r\n        pure\r\n        returns (uint256 loanSizeWithInterest)\r\n    {\r\n        uint256 interestForDuration = interestRate.mul(maxDuration).div(365 days);\r\n        uint256 divisor = uint256(10**20).sub(interestForDuration);\r\n        loanSizeWithInterest = loanSizeBeforeInterest.mul(10**20).div(divisor);\r\n    }\r\n\r\n    function _utilizationRate(\r\n        uint256 assetBorrow,\r\n        uint256 assetSupply)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (assetBorrow != 0 && assetSupply != 0) {\r\n            // U = total_borrow / total_supply\r\n            return assetBorrow\r\n                .mul(10**20)\r\n                .div(assetSupply);\r\n        }\r\n    }\r\n    \r\n    \r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"limits\",\"type\":\"uint256[]\"}],\"name\":\"SetTransactionLimits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetBorrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetSupply\",\"type\":\"uint256\"}],\"name\":\"_supplyInterestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"assetBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"avgBorrowInterestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"loanId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialLoanDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralTokenSent\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collateralTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"borrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"borrowInterestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"burnAmount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"loanAmountPaid\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"changeLoanTokenNameAndSymbol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkPause\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"checkpointPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkpointSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"collateralTokens\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"isTorqueLoans\",\"type\":\"bool[]\"}],\"name\":\"disableLoanParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialLoanDuration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collateralTokenAddress\",\"type\":\"address\"}],\"name\":\"getBorrowAmountForDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialLoanDuration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collateralTokenAddress\",\"type\":\"address\"}],\"name\":\"getDepositAmountForBorrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"leverageAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanTokenSent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralTokenSent\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collateralTokenAddress\",\"type\":\"address\"}],\"name\":\"getEstimatedMarginDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"leverageAmount\",\"type\":\"uint256\"}],\"name\":\"getMaxEscrowAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxEscrowAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kinkLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"loanParamsIds\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"loanTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lowUtilBaseRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lowUtilRateMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"loanId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"leverageAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanTokenSent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralTokenSent\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collateralTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"loanDataBytes\",\"type\":\"bytes\"}],\"name\":\"marginTrade\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxScaleRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"}],\"name\":\"nextBorrowInterestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"supplyAmount\",\"type\":\"uint256\"}],\"name\":\"nextSupplyInterestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pfiContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"profitOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rateMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_baseRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rateMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lowUtilBaseRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lowUtilRateMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_targetLevel\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_kinkLevel\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxScaleRate\",\"type\":\"uint256\"}],\"name\":\"setDemandCurve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"limits\",\"type\":\"uint256[]\"}],\"name\":\"setTransactionLimits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"loanToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minInitialMargin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maintenanceMargin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLoanTerm\",\"type\":\"uint256\"}],\"internalType\":\"struct LoanParamsStruct.LoanParams[]\",\"name\":\"loanParamsList\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"areTorqueLoans\",\"type\":\"bool\"}],\"name\":\"setupLoanParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supplyInterestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"targetLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"toggleFunctionPause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAssetBorrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAssetSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetSupply\",\"type\":\"uint256\"}],\"name\":\"totalSupplyInterestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"transactionLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wbaseTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "LoanTokenLogicStandard", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://ed710785a80bc52fd5a7168a525383a131f217b66ecdc285e48b1c2d6d6d8c84"}